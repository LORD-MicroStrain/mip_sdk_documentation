<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MIP_SDK: MicroStrain Strings [C]</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MIP_SDK
   &#160;<span id="projectnumber">v3.0.0-734-g6d224267</span>
   </div>
   <div id="projectbrief">MicroStrain Communications Library for embedded systems</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">MicroStrain Strings [C]<div class="ingroups"><a class="el" href="group__microstrain.html">MicroStrain API</a> &raquo; <a class="el" href="group__microstrain__strings.html">MicroStrain Strings</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>String manipulation in <a class="el" href="namespacemicrostrain_1_1C.html">C</a>.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gaac7e29cc0a3419921d6e2a85f492b3ba"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__microstrain__strings__c.html#gaac7e29cc0a3419921d6e2a85f492b3ba">microstrain_string_concat_l</a>(buffer,  buffer_size,  index,  str_lit)&#160;&#160;&#160;<a class="el" href="group__microstrain__strings__c.html#ga5c1815a3d8b2130b06c058bdd6908eb9">microstrain_string_concat</a>(buffer, buffer_size, index, str_lit, sizeof(str_lit)-1)</td></tr>
<tr class="separator:gaac7e29cc0a3419921d6e2a85f492b3ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga5c1815a3d8b2130b06c058bdd6908eb9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__microstrain__strings__c.html#ga5c1815a3d8b2130b06c058bdd6908eb9">microstrain::C::microstrain_string_concat</a> (char *buffer, size_t buffer_size, size_t *index, const char *str, size_t str_len)</td></tr>
<tr class="memdesc:ga5c1815a3d8b2130b06c058bdd6908eb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenate a string into a buffer.  <a href="group__microstrain__strings__c.html#ga5c1815a3d8b2130b06c058bdd6908eb9">More...</a><br /></td></tr>
<tr class="separator:ga5c1815a3d8b2130b06c058bdd6908eb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c835f65746ac41c256b8ddee68c7730"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__microstrain__strings__c.html#ga1c835f65746ac41c256b8ddee68c7730">microstrain::C::microstrain_string_concat_z</a> (char *buffer, size_t buffer_size, size_t *index, const char *str)</td></tr>
<tr class="memdesc:ga1c835f65746ac41c256b8ddee68c7730"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenate a string into a buffer.  <a href="group__microstrain__strings__c.html#ga1c835f65746ac41c256b8ddee68c7730">More...</a><br /></td></tr>
<tr class="separator:ga1c835f65746ac41c256b8ddee68c7730"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ae09b42f3832f2c021a0b62a9a43275"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__microstrain__strings__c.html#ga0ae09b42f3832f2c021a0b62a9a43275">microstrain::C::microstrain_string_format_v</a> (char *buffer, size_t buffer_size, size_t *index, const char *fmt, va_list args)</td></tr>
<tr class="memdesc:ga0ae09b42f3832f2c021a0b62a9a43275"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for std::vsnprintf with a better interface.  <a href="group__microstrain__strings__c.html#ga0ae09b42f3832f2c021a0b62a9a43275">More...</a><br /></td></tr>
<tr class="separator:ga0ae09b42f3832f2c021a0b62a9a43275"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga974a60540bb1cd014429dbbcd5b467c8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__microstrain__strings__c.html#ga974a60540bb1cd014429dbbcd5b467c8">microstrain::C::microstrain_string_format</a> (char *buffer, size_t buffer_size, size_t *index, const char *fmt,...)</td></tr>
<tr class="memdesc:ga974a60540bb1cd014429dbbcd5b467c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for std::snprintf with a better interface.  <a href="group__microstrain__strings__c.html#ga974a60540bb1cd014429dbbcd5b467c8">More...</a><br /></td></tr>
<tr class="separator:ga974a60540bb1cd014429dbbcd5b467c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ce840fc52858ca587cbd315b77b6946"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__microstrain__strings__c.html#ga8ce840fc52858ca587cbd315b77b6946">microstrain::C::microstrain_string_bytes_to_hex_str</a> (char *buffer, size_t buffer_size, size_t *index, const uint8_t *data, size_t data_size, unsigned int byte_grouping)</td></tr>
<tr class="memdesc:ga8ce840fc52858ca587cbd315b77b6946"><td class="mdescLeft">&#160;</td><td class="mdescRight">Formats a byte array to a text buffer in hexadecimal.  <a href="group__microstrain__strings__c.html#ga8ce840fc52858ca587cbd315b77b6946">More...</a><br /></td></tr>
<tr class="separator:ga8ce840fc52858ca587cbd315b77b6946"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="gaac7e29cc0a3419921d6e2a85f492b3ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaac7e29cc0a3419921d6e2a85f492b3ba">&#9670;&nbsp;</a></span>microstrain_string_concat_l</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define microstrain_string_concat_l</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">buffer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">buffer_size, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">index, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">str_lit&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="group__microstrain__strings__c.html#ga5c1815a3d8b2130b06c058bdd6908eb9">microstrain_string_concat</a>(buffer, buffer_size, index, str_lit, sizeof(str_lit)-1)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga5c1815a3d8b2130b06c058bdd6908eb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5c1815a3d8b2130b06c058bdd6908eb9">&#9670;&nbsp;</a></span>microstrain_string_concat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool microstrain::C::microstrain_string_concat </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>buffer_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>str_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">buffer</td><td>Pointer to buffer where str will be appended. Use NULL to just compute the required size (buffer_size must be 0 in that case). </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">buffer_size</td><td>Number of characters the buffer can hold, including the NULL terminator. Must be 0 if buffer is NULL. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">index</td><td>Position in buffer where string data will be written. It will be updated with the new index in all cases. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">str</td><td>String to be appended. Cannot be NULL unless str_len is 0. Does NOT require NULL termination, and any such termination is ignored. NULL characters will be appended just like any other character. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">str_len</td><td>Length of string (number of characters to copy). Usually you would set this to strlen(str). This overrides any NULL terminator in str.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if sufficient buffer space exists or if buffer is NULL. </dd>
<dd>
False if buffer is not NULL and insufficient space is available. </dd></dl>

</div>
</div>
<a id="ga1c835f65746ac41c256b8ddee68c7730"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1c835f65746ac41c256b8ddee68c7730">&#9670;&nbsp;</a></span>microstrain_string_concat_z()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool microstrain::C::microstrain_string_concat_z </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>buffer_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Equivalent to <code>microstrain_string_cat_n(buffer, buffer_size, index, str, strlen(str));</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">buffer</td><td>Pointer to buffer where str will be appended. Use NULL to just compute the required size (buffer_size must be 0 in that case). </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">buffer_size</td><td>Number of characters the buffer can hold, including the NULL terminator. Must be 0 if buffer is NULL. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">index</td><td>Position in buffer where string data will be written. It will be updated with the new index in all cases. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">str</td><td>String to be appended. NULL-termination is required.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if sufficient buffer space exists or if buffer is NULL. </dd>
<dd>
False if buffer is not NULL and insufficient space is available. </dd></dl>

</div>
</div>
<a id="ga0ae09b42f3832f2c021a0b62a9a43275"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0ae09b42f3832f2c021a0b62a9a43275">&#9670;&nbsp;</a></span>microstrain_string_format_v()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool microstrain::C::microstrain_string_format_v </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>buffer_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">va_list&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">buffer</td><td>Pointer to character buffer where string data will be stored. If this is NULL, this function will only compute the required buffer size (set buffer_size = 0 in this case). </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">buffer_size</td><td>Number of characters the buffer can hold, including the NULL terminator. Must be 0 if buffer is NULL. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">index</td><td>Position in buffer where string data will be written. It will be updated with the new index and will point to the new NULL terminator position. If insufficient space is available in buffer, index will still be updated even if it exceeds buffer_size. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">fmt</td><td>Format string similar to printf. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">args</td><td>List of formatting arguments similar to vprintf.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if successful </dd>
<dd>
False if an encoding error occurs (see snprintf). The index is unchanged in this case. </dd>
<dd>
False if insufficient space is available, unless buffer is NULL. </dd></dl>

</div>
</div>
<a id="ga974a60540bb1cd014429dbbcd5b467c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga974a60540bb1cd014429dbbcd5b467c8">&#9670;&nbsp;</a></span>microstrain_string_format()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool microstrain::C::microstrain_string_format </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>buffer_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">buffer</td><td>Pointer to character buffer where string data will be stored. If this is NULL, this function will only compute the required buffer size (set buffer_size = 0 in this case). </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">buffer_size</td><td>Number of characters the buffer can hold, including the NULL terminator. Must be 0 if buffer is NULL. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">index</td><td>Position in buffer where string data will be written. It will be updated with the new index and will point to the new NULL terminator position. If insufficient space is available in buffer, index will still be updated even if it exceeds buffer_size. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">fmt</td><td>Format string similar to printf.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if successful </dd>
<dd>
False if an encoding error occurs (see snprintf). The index is unchanged in this case. </dd>
<dd>
False if insufficient space is available, unless buffer is NULL. </dd></dl>

</div>
</div>
<a id="ga8ce840fc52858ca587cbd315b77b6946"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8ce840fc52858ca587cbd315b77b6946">&#9670;&nbsp;</a></span>microstrain_string_bytes_to_hex_str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool microstrain::C::microstrain_string_bytes_to_hex_str </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>buffer_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>data_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>byte_grouping</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>No additional characters are printed other than the hex values and spaces (if byte_grouping is positive). No leading or trailing space is printed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">buffer</td><td>Pointer to character buffer where string data will be stored. If this is NULL, this function will only compute the required buffer size (set buffer_size = 0 in this case). </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">buffer_size</td><td>Number of characters the buffer can hold, including the NULL terminator. Must be 0 if buffer is NULL. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">index</td><td>Position in buffer where string data will be written. It will be updated with the new index and will point to the new NULL terminator position. If insufficient space is available in buffer, index will still be updated even if it exceeds buffer_size. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">data</td><td>Data to be formatted. Can be NULL if data_size is 0. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">data_size</td><td>Number of bytes from data to print. Must be 0 if data is NULL. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">byte_grouping</td><td>If greater than zero, a space will be printed every byte_grouping bytes. E.g. a group of 2 will print pairs of bytes separated by spaces.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if successful </dd>
<dd>
False if an encoding error occurs (see snprintf). The index is unchanged in this case. </dd>
<dd>
False if insufficient space is available, unless buffer is NULL. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
