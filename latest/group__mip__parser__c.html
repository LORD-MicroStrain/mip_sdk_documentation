<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MIP_SDK: Mip Parser</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MIP_SDK
   &#160;<span id="projectnumber">latest-2-g2e1e70d</span>
   </div>
   <div id="projectbrief">MicroStrain Communications Library for embedded systems</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Mip Parser<div class="ingroups"><a class="el" href="group__mip.html">MIP</a> &raquo; <a class="el" href="group__mip__c.html">MIP C API</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Functions for parsing MIP packets.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmip_1_1C_1_1mip__parser.html">mip::C::mip_parser</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">MIP <a class="el" href="classmip_1_1Parser.html" title="C++ class representing a MIP parser.">Parser</a> state.  <a href="structmip_1_1C_1_1mip__parser.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga98e44886a7e7077f1cc08efc6a425724"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mip__parser__c.html#ga98e44886a7e7077f1cc08efc6a425724">MIP_PARSER_DEFAULT_TIMEOUT_MS</a>&#160;&#160;&#160;100</td></tr>
<tr class="memdesc:ga98e44886a7e7077f1cc08efc6a425724"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies the default timeout for a MIP parser, assuming timestamps are in milliseconds.  <a href="group__mip__parser__c.html#ga98e44886a7e7077f1cc08efc6a425724">More...</a><br /></td></tr>
<tr class="separator:ga98e44886a7e7077f1cc08efc6a425724"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga91de70c19d9857d8b69b276a6ae2c4f6"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mip__parser__c.html#ga91de70c19d9857d8b69b276a6ae2c4f6">mip::C::mip_packet_callback</a>) (void *user, const <a class="el" href="structmip_1_1C_1_1mip__packet__view.html">mip_packet_view</a> *packet, <a class="el" href="namespacemip_1_1C.html#a8a24a1913ffba77cdd608c5fb7575f37">mip_timestamp</a> timestamp)</td></tr>
<tr class="memdesc:ga91de70c19d9857d8b69b276a6ae2c4f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback function which receives parsed MIP packets.  <a href="group__mip__parser__c.html#ga91de70c19d9857d8b69b276a6ae2c4f6">More...</a><br /></td></tr>
<tr class="separator:ga91de70c19d9857d8b69b276a6ae2c4f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4e51a2bbfbb2530f5efb93bee705fd2"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structmip_1_1C_1_1mip__parser.html">mip::C::mip_parser</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mip__parser__c.html#gab4e51a2bbfbb2530f5efb93bee705fd2">mip::C::mip_parser</a></td></tr>
<tr class="memdesc:gab4e51a2bbfbb2530f5efb93bee705fd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">MIP <a class="el" href="classmip_1_1Parser.html" title="C++ class representing a MIP parser.">Parser</a> state.  <a href="group__mip__parser__c.html#gab4e51a2bbfbb2530f5efb93bee705fd2">More...</a><br /></td></tr>
<tr class="separator:gab4e51a2bbfbb2530f5efb93bee705fd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga54bf470ed57858c6483968e812308fb3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mip__parser__c.html#ga54bf470ed57858c6483968e812308fb3">mip::C::mip_parser_init</a> (<a class="el" href="structmip_1_1C_1_1mip__parser.html">mip_parser</a> *parser, <a class="el" href="group__mip__parser__c.html#ga91de70c19d9857d8b69b276a6ae2c4f6">mip_packet_callback</a> callback, void *callback_object, <a class="el" href="namespacemip_1_1C.html#aeb7a010ab523fc31b023122aa9b8e524">mip_timeout</a> timeout)</td></tr>
<tr class="memdesc:ga54bf470ed57858c6483968e812308fb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the MIP parser.  <a href="group__mip__parser__c.html#ga54bf470ed57858c6483968e812308fb3">More...</a><br /></td></tr>
<tr class="separator:ga54bf470ed57858c6483968e812308fb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafbd8fbf443d45e9972e107b999ee36b9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mip__parser__c.html#gafbd8fbf443d45e9972e107b999ee36b9">mip::C::mip_parser_parse</a> (<a class="el" href="structmip_1_1C_1_1mip__parser.html">mip_parser</a> *parser, const uint8_t *input_buffer, size_t input_length, <a class="el" href="namespacemip_1_1C.html#a8a24a1913ffba77cdd608c5fb7575f37">mip_timestamp</a> timestamp)</td></tr>
<tr class="memdesc:gafbd8fbf443d45e9972e107b999ee36b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse packets from a buffer.  <a href="group__mip__parser__c.html#gafbd8fbf443d45e9972e107b999ee36b9">More...</a><br /></td></tr>
<tr class="separator:gafbd8fbf443d45e9972e107b999ee36b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4169ceaa508424ea086aa3af5d82d998"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mip__parser__c.html#ga4169ceaa508424ea086aa3af5d82d998">mip::C::mip_parser_flush</a> (<a class="el" href="structmip_1_1C_1_1mip__parser.html">mip_parser</a> *parser)</td></tr>
<tr class="memdesc:ga4169ceaa508424ea086aa3af5d82d998"><td class="mdescLeft">&#160;</td><td class="mdescRight">Processes all previously buffered data.  <a href="group__mip__parser__c.html#ga4169ceaa508424ea086aa3af5d82d998">More...</a><br /></td></tr>
<tr class="separator:ga4169ceaa508424ea086aa3af5d82d998"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a0efb3d8c6af48d3141b69d763c916f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mip__parser__c.html#ga0a0efb3d8c6af48d3141b69d763c916f">mip::C::mip_parser_reset</a> (<a class="el" href="structmip_1_1C_1_1mip__parser.html">mip_parser</a> *parser)</td></tr>
<tr class="memdesc:ga0a0efb3d8c6af48d3141b69d763c916f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the MIP parser.  <a href="group__mip__parser__c.html#ga0a0efb3d8c6af48d3141b69d763c916f">More...</a><br /></td></tr>
<tr class="separator:ga0a0efb3d8c6af48d3141b69d763c916f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga665713329a7fa901e01f77d97dcc13fd"><td class="memItemLeft" align="right" valign="top">uint_least16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mip__parser__c.html#ga665713329a7fa901e01f77d97dcc13fd">mip::C::mip_parser_get_write_ptr</a> (<a class="el" href="structmip_1_1C_1_1mip__parser.html">mip_parser</a> *parser, uint8_t **ptr_out)</td></tr>
<tr class="memdesc:ga665713329a7fa901e01f77d97dcc13fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a pointer into which a small amount of data may be written for parsing.  <a href="group__mip__parser__c.html#ga665713329a7fa901e01f77d97dcc13fd">More...</a><br /></td></tr>
<tr class="separator:ga665713329a7fa901e01f77d97dcc13fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ec005011b45ab2e1d02ac6fb4ba38e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemip_1_1C.html#aeb7a010ab523fc31b023122aa9b8e524">mip_timeout</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mip__parser__c.html#ga6ec005011b45ab2e1d02ac6fb4ba38e8">mip::C::mip_parser_timeout</a> (const <a class="el" href="structmip_1_1C_1_1mip__parser.html">mip_parser</a> *parser)</td></tr>
<tr class="memdesc:ga6ec005011b45ab2e1d02ac6fb4ba38e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the packet timeout of the parser.  <a href="group__mip__parser__c.html#ga6ec005011b45ab2e1d02ac6fb4ba38e8">More...</a><br /></td></tr>
<tr class="separator:ga6ec005011b45ab2e1d02ac6fb4ba38e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca7d1f29de32505f98b72c321456b30b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mip__parser__c.html#gaca7d1f29de32505f98b72c321456b30b">mip::C::mip_parser_set_timeout</a> (<a class="el" href="structmip_1_1C_1_1mip__parser.html">mip_parser</a> *parser, <a class="el" href="namespacemip_1_1C.html#aeb7a010ab523fc31b023122aa9b8e524">mip_timeout</a> timeout)</td></tr>
<tr class="memdesc:gaca7d1f29de32505f98b72c321456b30b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the timeout of the MIP parser.  <a href="group__mip__parser__c.html#gaca7d1f29de32505f98b72c321456b30b">More...</a><br /></td></tr>
<tr class="separator:gaca7d1f29de32505f98b72c321456b30b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae4d87fe00549f44a43fc835eeae3d7b6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mip__parser__c.html#gae4d87fe00549f44a43fc835eeae3d7b6">mip::C::mip_parser_set_callback</a> (<a class="el" href="structmip_1_1C_1_1mip__parser.html">mip_parser</a> *parser, <a class="el" href="group__mip__parser__c.html#ga91de70c19d9857d8b69b276a6ae2c4f6">mip_packet_callback</a> callback, void *callback_object)</td></tr>
<tr class="memdesc:gae4d87fe00549f44a43fc835eeae3d7b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">mip_parser_set_callback  <a href="group__mip__parser__c.html#gae4d87fe00549f44a43fc835eeae3d7b6">More...</a><br /></td></tr>
<tr class="separator:gae4d87fe00549f44a43fc835eeae3d7b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac4bbc9c954c86695869a5c17258e03fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__mip__parser__c.html#ga91de70c19d9857d8b69b276a6ae2c4f6">mip_packet_callback</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mip__parser__c.html#gac4bbc9c954c86695869a5c17258e03fb">mip::C::mip_parser_callback</a> (const <a class="el" href="structmip_1_1C_1_1mip__parser.html">mip_parser</a> *parser)</td></tr>
<tr class="memdesc:gac4bbc9c954c86695869a5c17258e03fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">mip_parser_callback  <a href="group__mip__parser__c.html#gac4bbc9c954c86695869a5c17258e03fb">More...</a><br /></td></tr>
<tr class="separator:gac4bbc9c954c86695869a5c17258e03fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaceb97f49e14df07d85ce08ff17232d32"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mip__parser__c.html#gaceb97f49e14df07d85ce08ff17232d32">mip::C::mip_parser_callback_object</a> (const <a class="el" href="structmip_1_1C_1_1mip__parser.html">mip_parser</a> *parser)</td></tr>
<tr class="memdesc:gaceb97f49e14df07d85ce08ff17232d32"><td class="mdescLeft">&#160;</td><td class="mdescRight">mip_parser_callback  <a href="group__mip__parser__c.html#gaceb97f49e14df07d85ce08ff17232d32">More...</a><br /></td></tr>
<tr class="separator:gaceb97f49e14df07d85ce08ff17232d32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae980efff4b3880040a3045e0a203e106"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemip_1_1C.html#a8a24a1913ffba77cdd608c5fb7575f37">mip_timestamp</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mip__parser__c.html#gae980efff4b3880040a3045e0a203e106">mip::C::mip_parser_current_timestamp</a> (const <a class="el" href="structmip_1_1C_1_1mip__parser.html">mip_parser</a> *parser)</td></tr>
<tr class="memdesc:gae980efff4b3880040a3045e0a203e106"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the timestamp of the last parsed packet.  <a href="group__mip__parser__c.html#gae980efff4b3880040a3045e0a203e106">More...</a><br /></td></tr>
<tr class="separator:gae980efff4b3880040a3045e0a203e106"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga519bccb69b9fff2cb3bc8bed2cbcc1f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemip_1_1C.html#aeb7a010ab523fc31b023122aa9b8e524">mip_timeout</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mip__parser__c.html#ga519bccb69b9fff2cb3bc8bed2cbcc1f3">mip::C::mip_timeout_from_baudrate</a> (uint32_t baudrate)</td></tr>
<tr class="memdesc:ga519bccb69b9fff2cb3bc8bed2cbcc1f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes an appropriate packet timeout for a given serial baud rate.  <a href="group__mip__parser__c.html#ga519bccb69b9fff2cb3bc8bed2cbcc1f3">More...</a><br /></td></tr>
<tr class="separator:ga519bccb69b9fff2cb3bc8bed2cbcc1f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Functions for parsing MIP packets. </p>
<p>See <a class="el" href="parsing_packets.html">Mip Parser</a></p>
<p>Typical usage: </p><ul>
<li>Declare a <a class="el" href="structmip_1_1C_1_1mip__parser.html" title="MIP Parser state.">mip_parser</a> struct </li>
<li>Determine the packet timeout, e.g. with <a class="el" href="group__mip__parser__c.html#ga519bccb69b9fff2cb3bc8bed2cbcc1f3" title="Computes an appropriate packet timeout for a given serial baud rate.">mip_timeout_from_baudrate()</a>. </li>
<li>Call <a class="el" href="group__mip__parser__c.html#ga54bf470ed57858c6483968e812308fb3" title="Initializes the MIP parser.">mip_parser_init()</a>, passing the struct, timeout, and callback function. </li>
<li>Periodically call <a class="el" href="group__mip__parser__c.html#gafbd8fbf443d45e9972e107b999ee36b9" title="Parse packets from a buffer.">mip_parser_parse()</a>. </li>
</ul>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga98e44886a7e7077f1cc08efc6a425724"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga98e44886a7e7077f1cc08efc6a425724">&#9670;&nbsp;</a></span>MIP_PARSER_DEFAULT_TIMEOUT_MS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MIP_PARSER_DEFAULT_TIMEOUT_MS&#160;&#160;&#160;100</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies the default timeout for a MIP parser, assuming timestamps are in milliseconds. </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga91de70c19d9857d8b69b276a6ae2c4f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga91de70c19d9857d8b69b276a6ae2c4f6">&#9670;&nbsp;</a></span>mip_packet_callback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* mip::C::mip_packet_callback) (void *user, const <a class="el" href="structmip_1_1C_1_1mip__packet__view.html">mip_packet_view</a> *packet, <a class="el" href="namespacemip_1_1C.html#a8a24a1913ffba77cdd608c5fb7575f37">mip_timestamp</a> timestamp)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback function which receives parsed MIP packets. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">user</td><td>A user-specified pointer which will be given the callback_object parameter which was previously passed to mip_parser_init. </td></tr>
    <tr><td class="paramname">packet</td><td>A pointer to the MIP packet. Do not store this pointer as it will be invalidated after the callback returns. </td></tr>
    <tr><td class="paramname">timestamp</td><td>The approximate time the packet was parsed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab4e51a2bbfbb2530f5efb93bee705fd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab4e51a2bbfbb2530f5efb93bee705fd2">&#9670;&nbsp;</a></span>mip_parser</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structmip_1_1C_1_1mip__parser.html">mip::C::mip_parser</a> <a class="el" href="structmip_1_1C_1_1mip__parser.html">mip::C::mip_parser</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>MIP <a class="el" href="classmip_1_1Parser.html" title="C++ class representing a MIP parser.">Parser</a> state. </p>
<dl class="section note"><dt>Note</dt><dd>This should be considered an "opaque" structure; its members should be considered an internal implementation detail. Avoid accessing them directly as they are subject to change in future versions of this software. </dd></dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gac4bbc9c954c86695869a5c17258e03fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac4bbc9c954c86695869a5c17258e03fb">&#9670;&nbsp;</a></span>mip_parser_callback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__mip__parser__c.html#ga91de70c19d9857d8b69b276a6ae2c4f6">mip_packet_callback</a> mip::C::mip_parser_callback </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmip_1_1C_1_1mip__parser.html">mip_parser</a> *&#160;</td>
          <td class="paramname"><em>parser</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>mip_parser_callback </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parser</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the packet callback function. </dd></dl>

</div>
</div>
<a id="gaceb97f49e14df07d85ce08ff17232d32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaceb97f49e14df07d85ce08ff17232d32">&#9670;&nbsp;</a></span>mip_parser_callback_object()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * mip::C::mip_parser_callback_object </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmip_1_1C_1_1mip__parser.html">mip_parser</a> *&#160;</td>
          <td class="paramname"><em>parser</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>mip_parser_callback </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parser</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the packet callback user data pointer. </dd></dl>

</div>
</div>
<a id="gae980efff4b3880040a3045e0a203e106"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae980efff4b3880040a3045e0a203e106">&#9670;&nbsp;</a></span>mip_parser_current_timestamp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemip_1_1C.html#a8a24a1913ffba77cdd608c5fb7575f37">mip_timestamp</a> mip::C::mip_parser_current_timestamp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmip_1_1C_1_1mip__parser.html">mip_parser</a> *&#160;</td>
          <td class="paramname"><em>parser</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the timestamp of the last parsed packet. </p>
<p>This is only valid after a valid packet has been parsed.</p>
<p>This function is provided to allow additional calls to <a class="el" href="group__mip__parser__c.html#gafbd8fbf443d45e9972e107b999ee36b9" title="Parse packets from a buffer.">mip_parser_parse()</a> with no input data (buffer=NULL and length=0) when max_packets &gt; 0. The additional calls can use the same timestamp because no new data will be processed.</p>
<p>There are two possible situations after the last call to parse:</p><ol type="1">
<li>Either max_packets was reached, meaning at least one packet was parsed, and thus the timestamp is valid, or</li>
<li>More data is required, in which case this time may not be valid, but it won't matter because an additional call to parse won't produce a new packet to be timestamped. </li>
</ol>

</div>
</div>
<a id="ga4169ceaa508424ea086aa3af5d82d998"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4169ceaa508424ea086aa3af5d82d998">&#9670;&nbsp;</a></span>mip_parser_flush()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mip::C::mip_parser_flush </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmip_1_1C_1_1mip__parser.html">mip_parser</a> *&#160;</td>
          <td class="paramname"><em>parser</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Processes all previously buffered data. </p>
<p>Call this at the end of reading a binary file to ensure that any trailing packets are fully processed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parser</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga665713329a7fa901e01f77d97dcc13fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga665713329a7fa901e01f77d97dcc13fd">&#9670;&nbsp;</a></span>mip_parser_get_write_ptr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint_least16_t mip::C::mip_parser_get_write_ptr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmip_1_1C_1_1mip__parser.html">mip_parser</a> *&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t **&#160;</td>
          <td class="paramname"><em>ptr_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets a pointer into which a small amount of data may be written for parsing. </p>
<p>Generally you should call mip_parser_parse with your input buffer directly. This method may be more efficient for data which arrives in small chunks by avoiding an intermediate buffer. However, for large chunks of data (e.g. reading from a file) it's more efficient to declare a bigger buffer (at least 1024 bytes) and parse that instead.</p>
<p>@caution If you use this function, you must call mip_parser_parse with input_buffer=NULL and input_length equal to the number of bytes written into the parser. Otherwise the data will be lost.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">parser</td><td></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ptr_out</td><td>Pointer to a pointer which will be set to an internal buffer location.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The maximum number of bytes which may be written to the parser. This will never be more than the maximum MIP packet size. </dd></dl>

</div>
</div>
<a id="ga54bf470ed57858c6483968e812308fb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga54bf470ed57858c6483968e812308fb3">&#9670;&nbsp;</a></span>mip_parser_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mip::C::mip_parser_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmip_1_1C_1_1mip__parser.html">mip_parser</a> *&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mip__parser__c.html#ga91de70c19d9857d8b69b276a6ae2c4f6">mip_packet_callback</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>callback_object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemip_1_1C.html#aeb7a010ab523fc31b023122aa9b8e524">mip_timeout</a>&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the MIP parser. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parser</td><td></td></tr>
    <tr><td class="paramname">callback</td><td>A function to be called when a valid packet is identified. It will be passed an optional user-supplied parameter, a pointer to the packet, and the time the first byte was parsed. </td></tr>
    <tr><td class="paramname">callback_object</td><td>An optional user-specified pointer which is directly passed to the callback as the first parameter. </td></tr>
    <tr><td class="paramname">timeout</td><td>The timeout for receiving one packet. Depends on the serial baud rate and is typically 100 milliseconds. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gafbd8fbf443d45e9972e107b999ee36b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafbd8fbf443d45e9972e107b999ee36b9">&#9670;&nbsp;</a></span>mip_parser_parse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mip::C::mip_parser_parse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmip_1_1C_1_1mip__parser.html">mip_parser</a> *&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>input_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>input_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemip_1_1C.html#a8a24a1913ffba77cdd608c5fb7575f37">mip_timestamp</a>&#160;</td>
          <td class="paramname"><em>timestamp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse packets from a buffer. </p>
<p>The buffer may contain non-mip data (e.g. NMEA 0183) which will be ignored.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parser</td><td></td></tr>
    <tr><td class="paramname">input_buffer</td><td>Buffer from which to parse packets. If NULL, parses from the internal buffer instead (see mip_parser_get_write_ptr). </td></tr>
    <tr><td class="paramname">input_length</td><td>Length of data in the buffer. </td></tr>
    <tr><td class="paramname">timestamp</td><td>Time of arrival of the data to be parsed. This is used to set packets' timestamp and to time out incomplete packets.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The timestamp of a packet is based on the time the packet was parsed. Packets received during an earlier parse call may be timestamped with the time from a later parse call, but will never be timestamped before they were actually received.</dd>
<dd>
The parser will do its best to ignore non-MIP data. However, it is possible for some binary data to appear to be a MIP packet if it contains the two-byte sequence 0x75, 0x65. This may cause temporary stalls in parsed data if the following bytes suggest that more data is needed to complete the "packet". Once the fake packet times out or enough data is received, real MIP packets received in the meantime will be properly parsed. Note that the 16-bit checksum has a 1 in 65,536 chance of appearing to be valid at random. </dd></dl>

</div>
</div>
<a id="ga0a0efb3d8c6af48d3141b69d763c916f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0a0efb3d8c6af48d3141b69d763c916f">&#9670;&nbsp;</a></span>mip_parser_reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mip::C::mip_parser_reset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmip_1_1C_1_1mip__parser.html">mip_parser</a> *&#160;</td>
          <td class="paramname"><em>parser</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resets the MIP parser. </p>
<p>Clears the current packet and internal buffer. The parser will be restored as if mip_parser_init had just been called.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parser</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae4d87fe00549f44a43fc835eeae3d7b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae4d87fe00549f44a43fc835eeae3d7b6">&#9670;&nbsp;</a></span>mip_parser_set_callback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mip::C::mip_parser_set_callback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmip_1_1C_1_1mip__parser.html">mip_parser</a> *&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mip__parser__c.html#ga91de70c19d9857d8b69b276a6ae2c4f6">mip_packet_callback</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>callback_object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>mip_parser_set_callback </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parser</td><td></td></tr>
    <tr><td class="paramname">callback</td><td></td></tr>
    <tr><td class="paramname">callback_object</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaca7d1f29de32505f98b72c321456b30b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaca7d1f29de32505f98b72c321456b30b">&#9670;&nbsp;</a></span>mip_parser_set_timeout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mip::C::mip_parser_set_timeout </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmip_1_1C_1_1mip__parser.html">mip_parser</a> *&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemip_1_1C.html#aeb7a010ab523fc31b023122aa9b8e524">mip_timeout</a>&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Changes the timeout of the MIP parser. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parser</td><td></td></tr>
    <tr><td class="paramname">timeout</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6ec005011b45ab2e1d02ac6fb4ba38e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6ec005011b45ab2e1d02ac6fb4ba38e8">&#9670;&nbsp;</a></span>mip_parser_timeout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemip_1_1C.html#aeb7a010ab523fc31b023122aa9b8e524">mip_timeout</a> mip::C::mip_parser_timeout </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmip_1_1C_1_1mip__parser.html">mip_parser</a> *&#160;</td>
          <td class="paramname"><em>parser</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the packet timeout of the parser. </p>

</div>
</div>
<a id="ga519bccb69b9fff2cb3bc8bed2cbcc1f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga519bccb69b9fff2cb3bc8bed2cbcc1f3">&#9670;&nbsp;</a></span>mip_timeout_from_baudrate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemip_1_1C.html#aeb7a010ab523fc31b023122aa9b8e524">mip_timeout</a> mip::C::mip_timeout_from_baudrate </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baudrate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes an appropriate packet timeout for a given serial baud rate. </p>
<dl class="section note"><dt>Note</dt><dd>This function assumes a standard serial port with 10 symbols per byte: 1 start bit, 8 data bits, and 1 stop bit.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baudrate</td><td>Serial baud rate in bits per second</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A timeout value in ms representing the time it would take to transmit a single mip packet of maximum size at the given baud rate, plus some tolerance. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
