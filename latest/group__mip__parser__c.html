<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MIP_SDK: Mip Parser</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MIP_SDK
   &#160;<span id="projectnumber">v2.0.0-160-gfd99dac</span>
   </div>
   <div id="projectbrief">MicroStrain Communications Library for embedded systems</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Mip Parser<div class="ingroups"><a class="el" href="group__mip.html">MIP</a> &raquo; <a class="el" href="group__mip__c.html">MIP C API</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Functions for parsing MIP packets.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmip_1_1C_1_1mip__parser.html">mip::C::mip_parser</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">MIP <a class="el" href="classmip_1_1Parser.html" title="C++ class representing a MIP parser.">Parser</a> state.  <a href="structmip_1_1C_1_1mip__parser.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga0d610cd9ccf7b165bba3097ef9ab5090"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mip__parser__c.html#ga0d610cd9ccf7b165bba3097ef9ab5090">MIPPARSER_UNLIMITED_PACKETS</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:ga0d610cd9ccf7b165bba3097ef9ab5090"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies no limit when used as the max_packets argument to mip_parser_parse.  <a href="group__mip__parser__c.html#ga0d610cd9ccf7b165bba3097ef9ab5090">More...</a><br /></td></tr>
<tr class="separator:ga0d610cd9ccf7b165bba3097ef9ab5090"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a13a333109e93da5e9a94982be2e0ea"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mip__parser__c.html#ga0a13a333109e93da5e9a94982be2e0ea">MIPPARSER_DEFAULT_TIMEOUT_MS</a>&#160;&#160;&#160;100</td></tr>
<tr class="memdesc:ga0a13a333109e93da5e9a94982be2e0ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies the default timeout for a MIP parser, assuming timestamps are in milliseconds.  <a href="group__mip__parser__c.html#ga0a13a333109e93da5e9a94982be2e0ea">More...</a><br /></td></tr>
<tr class="separator:ga0a13a333109e93da5e9a94982be2e0ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga03a7f91bb53f364bbd14c6db26c7617f"><td class="memItemLeft" align="right" valign="top">typedef bool(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mip__parser__c.html#ga03a7f91bb53f364bbd14c6db26c7617f">mip::C::mip_packet_callback</a>) (void *user, const <a class="el" href="structmip_1_1C_1_1mip__packet__view.html">mip_packet_view</a> *packet, <a class="el" href="namespacemip_1_1C.html#a8a24a1913ffba77cdd608c5fb7575f37">mip_timestamp</a> timestamp)</td></tr>
<tr class="memdesc:ga03a7f91bb53f364bbd14c6db26c7617f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback function which receives parsed MIP packets.  <a href="group__mip__parser__c.html#ga03a7f91bb53f364bbd14c6db26c7617f">More...</a><br /></td></tr>
<tr class="separator:ga03a7f91bb53f364bbd14c6db26c7617f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4e51a2bbfbb2530f5efb93bee705fd2"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structmip_1_1C_1_1mip__parser.html">mip::C::mip_parser</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mip__parser__c.html#gab4e51a2bbfbb2530f5efb93bee705fd2">mip::C::mip_parser</a></td></tr>
<tr class="memdesc:gab4e51a2bbfbb2530f5efb93bee705fd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">MIP <a class="el" href="classmip_1_1Parser.html" title="C++ class representing a MIP parser.">Parser</a> state.  <a href="group__mip__parser__c.html#gab4e51a2bbfbb2530f5efb93bee705fd2">More...</a><br /></td></tr>
<tr class="separator:gab4e51a2bbfbb2530f5efb93bee705fd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gac9af1af2bc9e6c2b814949c84d4f3713"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mip__parser__c.html#gac9af1af2bc9e6c2b814949c84d4f3713">mip::C::mip_parser_init</a> (<a class="el" href="structmip_1_1C_1_1mip__parser.html">mip_parser</a> *parser, uint8_t *buffer, size_t buffer_size, <a class="el" href="group__mip__parser__c.html#ga03a7f91bb53f364bbd14c6db26c7617f">mip_packet_callback</a> callback, void *callback_object, <a class="el" href="namespacemip_1_1C.html#a8a24a1913ffba77cdd608c5fb7575f37">mip_timestamp</a> timeout)</td></tr>
<tr class="memdesc:gac9af1af2bc9e6c2b814949c84d4f3713"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the MIP parser.  <a href="group__mip__parser__c.html#gac9af1af2bc9e6c2b814949c84d4f3713">More...</a><br /></td></tr>
<tr class="separator:gac9af1af2bc9e6c2b814949c84d4f3713"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga928471c1dbd07ae1c414b3159f78c609"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mip__parser__c.html#ga928471c1dbd07ae1c414b3159f78c609">mip::C::mip_parser_parse_one_packet_from_ring</a> (<a class="el" href="structmip_1_1C_1_1mip__parser.html">mip_parser</a> *parser, <a class="el" href="structmip_1_1C_1_1mip__packet__view.html">mip_packet_view</a> *packet_out, <a class="el" href="namespacemip_1_1C.html#a8a24a1913ffba77cdd608c5fb7575f37">mip_timestamp</a> timestamp)</td></tr>
<tr class="memdesc:ga928471c1dbd07ae1c414b3159f78c609"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses a single packet from the internal buffer.  <a href="group__mip__parser__c.html#ga928471c1dbd07ae1c414b3159f78c609">More...</a><br /></td></tr>
<tr class="separator:ga928471c1dbd07ae1c414b3159f78c609"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef053e67bd8b8e8398b863818a3fc270"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mip__parser__c.html#gaef053e67bd8b8e8398b863818a3fc270">mip::C::mip_parser_parse</a> (<a class="el" href="structmip_1_1C_1_1mip__parser.html">mip_parser</a> *parser, const uint8_t *input_buffer, size_t input_count, <a class="el" href="namespacemip_1_1C.html#a8a24a1913ffba77cdd608c5fb7575f37">mip_timestamp</a> timestamp, unsigned int max_packets)</td></tr>
<tr class="memdesc:gaef053e67bd8b8e8398b863818a3fc270"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses packets from the input data buffer.  <a href="group__mip__parser__c.html#gaef053e67bd8b8e8398b863818a3fc270">More...</a><br /></td></tr>
<tr class="separator:gaef053e67bd8b8e8398b863818a3fc270"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a0efb3d8c6af48d3141b69d763c916f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mip__parser__c.html#ga0a0efb3d8c6af48d3141b69d763c916f">mip::C::mip_parser_reset</a> (<a class="el" href="structmip_1_1C_1_1mip__parser.html">mip_parser</a> *parser)</td></tr>
<tr class="memdesc:ga0a0efb3d8c6af48d3141b69d763c916f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the MIP parser.  <a href="group__mip__parser__c.html#ga0a0efb3d8c6af48d3141b69d763c916f">More...</a><br /></td></tr>
<tr class="separator:ga0a0efb3d8c6af48d3141b69d763c916f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ea8146c52227b0f5b5edd091ba4fa38"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mip__parser__c.html#ga5ea8146c52227b0f5b5edd091ba4fa38">mip::C::mip_parser_get_write_ptr</a> (<a class="el" href="structmip_1_1C_1_1mip__parser.html">mip_parser</a> *parser, uint8_t **const ptr_out)</td></tr>
<tr class="memdesc:ga5ea8146c52227b0f5b5edd091ba4fa38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain a pointer into which data may be read for processing.  <a href="group__mip__parser__c.html#ga5ea8146c52227b0f5b5edd091ba4fa38">More...</a><br /></td></tr>
<tr class="separator:ga5ea8146c52227b0f5b5edd091ba4fa38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d3b5a3755b3d2b379f5471fab7e3657"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mip__parser__c.html#ga2d3b5a3755b3d2b379f5471fab7e3657">mip::C::mip_parser_process_written</a> (<a class="el" href="structmip_1_1C_1_1mip__parser.html">mip_parser</a> *parser, size_t count, <a class="el" href="namespacemip_1_1C.html#a8a24a1913ffba77cdd608c5fb7575f37">mip_timestamp</a> timestamp, unsigned int max_packets)</td></tr>
<tr class="memdesc:ga2d3b5a3755b3d2b379f5471fab7e3657"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notify the parser that data has been written to the pointer previously obtained via <a class="el" href="group__mip__parser__c.html#ga5ea8146c52227b0f5b5edd091ba4fa38" title="Obtain a pointer into which data may be read for processing.">mip_parser_get_write_ptr()</a>.  <a href="group__mip__parser__c.html#ga2d3b5a3755b3d2b379f5471fab7e3657">More...</a><br /></td></tr>
<tr class="separator:ga2d3b5a3755b3d2b379f5471fab7e3657"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ec005011b45ab2e1d02ac6fb4ba38e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemip_1_1C.html#a8a24a1913ffba77cdd608c5fb7575f37">mip_timestamp</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mip__parser__c.html#ga6ec005011b45ab2e1d02ac6fb4ba38e8">mip::C::mip_parser_timeout</a> (const <a class="el" href="structmip_1_1C_1_1mip__parser.html">mip_parser</a> *parser)</td></tr>
<tr class="memdesc:ga6ec005011b45ab2e1d02ac6fb4ba38e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the packet timeout of the parser.  <a href="group__mip__parser__c.html#ga6ec005011b45ab2e1d02ac6fb4ba38e8">More...</a><br /></td></tr>
<tr class="separator:ga6ec005011b45ab2e1d02ac6fb4ba38e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6af81c0668e6636fa596e7cab977322"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mip__parser__c.html#gac6af81c0668e6636fa596e7cab977322">mip::C::mip_parser_set_timeout</a> (<a class="el" href="structmip_1_1C_1_1mip__parser.html">mip_parser</a> *parser, <a class="el" href="namespacemip_1_1C.html#a8a24a1913ffba77cdd608c5fb7575f37">mip_timestamp</a> timeout)</td></tr>
<tr class="memdesc:gac6af81c0668e6636fa596e7cab977322"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the timeout of the MIP parser.  <a href="group__mip__parser__c.html#gac6af81c0668e6636fa596e7cab977322">More...</a><br /></td></tr>
<tr class="separator:gac6af81c0668e6636fa596e7cab977322"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae4d87fe00549f44a43fc835eeae3d7b6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mip__parser__c.html#gae4d87fe00549f44a43fc835eeae3d7b6">mip::C::mip_parser_set_callback</a> (<a class="el" href="structmip_1_1C_1_1mip__parser.html">mip_parser</a> *parser, <a class="el" href="group__mip__parser__c.html#ga03a7f91bb53f364bbd14c6db26c7617f">mip_packet_callback</a> callback, void *callback_object)</td></tr>
<tr class="memdesc:gae4d87fe00549f44a43fc835eeae3d7b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">mip_parser_set_callback  <a href="group__mip__parser__c.html#gae4d87fe00549f44a43fc835eeae3d7b6">More...</a><br /></td></tr>
<tr class="separator:gae4d87fe00549f44a43fc835eeae3d7b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac4bbc9c954c86695869a5c17258e03fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__mip__parser__c.html#ga03a7f91bb53f364bbd14c6db26c7617f">mip_packet_callback</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mip__parser__c.html#gac4bbc9c954c86695869a5c17258e03fb">mip::C::mip_parser_callback</a> (const <a class="el" href="structmip_1_1C_1_1mip__parser.html">mip_parser</a> *parser)</td></tr>
<tr class="memdesc:gac4bbc9c954c86695869a5c17258e03fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">mip_parser_callback  <a href="group__mip__parser__c.html#gac4bbc9c954c86695869a5c17258e03fb">More...</a><br /></td></tr>
<tr class="separator:gac4bbc9c954c86695869a5c17258e03fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaceb97f49e14df07d85ce08ff17232d32"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mip__parser__c.html#gaceb97f49e14df07d85ce08ff17232d32">mip::C::mip_parser_callback_object</a> (const <a class="el" href="structmip_1_1C_1_1mip__parser.html">mip_parser</a> *parser)</td></tr>
<tr class="memdesc:gaceb97f49e14df07d85ce08ff17232d32"><td class="mdescLeft">&#160;</td><td class="mdescRight">mip_parser_callback  <a href="group__mip__parser__c.html#gaceb97f49e14df07d85ce08ff17232d32">More...</a><br /></td></tr>
<tr class="separator:gaceb97f49e14df07d85ce08ff17232d32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab846b0b808bbc5b6e24381d13fbda256"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemip_1_1C.html#a8a24a1913ffba77cdd608c5fb7575f37">mip_timestamp</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mip__parser__c.html#gab846b0b808bbc5b6e24381d13fbda256">mip::C::mip_parser_last_packet_timestamp</a> (const <a class="el" href="structmip_1_1C_1_1mip__parser.html">mip_parser</a> *parser)</td></tr>
<tr class="memdesc:gab846b0b808bbc5b6e24381d13fbda256"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the timestamp of the last parsed packet.  <a href="group__mip__parser__c.html#gab846b0b808bbc5b6e24381d13fbda256">More...</a><br /></td></tr>
<tr class="separator:gab846b0b808bbc5b6e24381d13fbda256"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga519bccb69b9fff2cb3bc8bed2cbcc1f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemip_1_1C.html#aeb7a010ab523fc31b023122aa9b8e524">mip_timeout</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mip__parser__c.html#ga519bccb69b9fff2cb3bc8bed2cbcc1f3">mip::C::mip_timeout_from_baudrate</a> (uint32_t baudrate)</td></tr>
<tr class="memdesc:ga519bccb69b9fff2cb3bc8bed2cbcc1f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes an appropriate packet timeout for a given serial baud rate.  <a href="group__mip__parser__c.html#ga519bccb69b9fff2cb3bc8bed2cbcc1f3">More...</a><br /></td></tr>
<tr class="separator:ga519bccb69b9fff2cb3bc8bed2cbcc1f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Functions for parsing MIP packets. </p>
<p>See <a class="el" href="parsing_packets.html">Mip Parser</a></p>
<p>Typical usage: </p><ul>
<li>Declare a <a class="el" href="structmip_1_1C_1_1mip__parser.html" title="MIP Parser state.">mip_parser</a> struct </li>
<li>Declare a uint8_t buffer of some size which is at least 512 and a power of 2. </li>
<li>Determine the packet timeout, e.g. with <a class="el" href="group__mip__parser__c.html#ga519bccb69b9fff2cb3bc8bed2cbcc1f3" title="Computes an appropriate packet timeout for a given serial baud rate.">mip_timeout_from_baudrate()</a>. </li>
<li>Call <a class="el" href="group__mip__parser__c.html#gac9af1af2bc9e6c2b814949c84d4f3713" title="Initializes the MIP parser.">mip_parser_init()</a>, passing the struct, buffer, buffer size, timeout, and callback function. </li>
<li>Periodically call <a class="el" href="group__mip__parser__c.html#gaef053e67bd8b8e8398b863818a3fc270" title="Parses packets from the input data buffer.">mip_parser_parse()</a>. </li>
</ul>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga0a13a333109e93da5e9a94982be2e0ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0a13a333109e93da5e9a94982be2e0ea">&#9670;&nbsp;</a></span>MIPPARSER_DEFAULT_TIMEOUT_MS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MIPPARSER_DEFAULT_TIMEOUT_MS&#160;&#160;&#160;100</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies the default timeout for a MIP parser, assuming timestamps are in milliseconds. </p>

</div>
</div>
<a id="ga0d610cd9ccf7b165bba3097ef9ab5090"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0d610cd9ccf7b165bba3097ef9ab5090">&#9670;&nbsp;</a></span>MIPPARSER_UNLIMITED_PACKETS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MIPPARSER_UNLIMITED_PACKETS&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies no limit when used as the max_packets argument to mip_parser_parse. </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga03a7f91bb53f364bbd14c6db26c7617f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga03a7f91bb53f364bbd14c6db26c7617f">&#9670;&nbsp;</a></span>mip_packet_callback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef bool(* mip::C::mip_packet_callback) (void *user, const <a class="el" href="structmip_1_1C_1_1mip__packet__view.html">mip_packet_view</a> *packet, <a class="el" href="namespacemip_1_1C.html#a8a24a1913ffba77cdd608c5fb7575f37">mip_timestamp</a> timestamp)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback function which receives parsed MIP packets. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">user</td><td>A user-specified pointer which will be given the callback_object parameter which was previously passed to mip_parser_init. </td></tr>
    <tr><td class="paramname">packet</td><td>A pointer to the MIP packet. Do not store this pointer as it will be invalidated after the callback returns. </td></tr>
    <tr><td class="paramname">timestamp</td><td>The approximate time the packet was parsed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab4e51a2bbfbb2530f5efb93bee705fd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab4e51a2bbfbb2530f5efb93bee705fd2">&#9670;&nbsp;</a></span>mip_parser</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structmip_1_1C_1_1mip__parser.html">mip::C::mip_parser</a> <a class="el" href="structmip_1_1C_1_1mip__parser.html">mip::C::mip_parser</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>MIP <a class="el" href="classmip_1_1Parser.html" title="C++ class representing a MIP parser.">Parser</a> state. </p>
<dl class="section note"><dt>Note</dt><dd>This should be considered an "opaque" structure; its members should be considered an internal implementation detail. Avoid accessing them directly as they are subject to change in future versions of this software. </dd></dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gac4bbc9c954c86695869a5c17258e03fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac4bbc9c954c86695869a5c17258e03fb">&#9670;&nbsp;</a></span>mip_parser_callback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__mip__parser__c.html#ga03a7f91bb53f364bbd14c6db26c7617f">mip_packet_callback</a> mip::C::mip_parser_callback </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmip_1_1C_1_1mip__parser.html">mip_parser</a> *&#160;</td>
          <td class="paramname"><em>parser</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>mip_parser_callback </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parser</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the packet callback function. </dd></dl>

</div>
</div>
<a id="gaceb97f49e14df07d85ce08ff17232d32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaceb97f49e14df07d85ce08ff17232d32">&#9670;&nbsp;</a></span>mip_parser_callback_object()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * mip::C::mip_parser_callback_object </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmip_1_1C_1_1mip__parser.html">mip_parser</a> *&#160;</td>
          <td class="paramname"><em>parser</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>mip_parser_callback </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parser</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the packet callback user data pointer. </dd></dl>

</div>
</div>
<a id="ga5ea8146c52227b0f5b5edd091ba4fa38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5ea8146c52227b0f5b5edd091ba4fa38">&#9670;&nbsp;</a></span>mip_parser_get_write_ptr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t mip::C::mip_parser_get_write_ptr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmip_1_1C_1_1mip__parser.html">mip_parser</a> *&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t **const&#160;</td>
          <td class="paramname"><em>ptr_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain a pointer into which data may be read for processing. </p>
<p>Use this function when the source data stream (e.g. a file or serial port) requires that you pass in a buffer when reading data. This avoids the need for an intermediate buffer.</p>
<p>Call <a class="el" href="group__mip__parser__c.html#ga2d3b5a3755b3d2b379f5471fab7e3657" title="Notify the parser that data has been written to the pointer previously obtained via mip_parser_get_wr...">mip_parser_process_written()</a> after the data has been read to update the buffer count and process any packets.</p>
<div class="fragment"><div class="line">uint8_t ptr;</div>
<div class="line"><span class="keywordtype">size_t</span> space = <a class="code" href="group__mip__parser__c.html#ga5ea8146c52227b0f5b5edd091ba4fa38">mip_parser_get_write_ptr</a>(&amp;parser, &amp;ptr);</div>
<div class="line"><span class="keywordtype">size_t</span> used = fread(ptr, 1, space, file);</div>
<div class="line"><a class="code" href="group__mip__parser__c.html#ga2d3b5a3755b3d2b379f5471fab7e3657">mip_parser_process_written</a>(&amp;parser, used);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parser</td><td></td></tr>
    <tr><td class="paramname">ptr_out</td><td>A pointer to a pointer which will be set to the buffer where data should be written. Cannot be NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>How many bytes can be written to the buffer. Due to the use of a cicular buffer, this may be less than the total available buffer space. Do not write more data than specified. </dd></dl>

</div>
</div>
<a id="gac9af1af2bc9e6c2b814949c84d4f3713"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac9af1af2bc9e6c2b814949c84d4f3713">&#9670;&nbsp;</a></span>mip_parser_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mip::C::mip_parser_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmip_1_1C_1_1mip__parser.html">mip_parser</a> *&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>buffer_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mip__parser__c.html#ga03a7f91bb53f364bbd14c6db26c7617f">mip_packet_callback</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>callback_object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemip_1_1C.html#a8a24a1913ffba77cdd608c5fb7575f37">mip_timestamp</a>&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the MIP parser. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parser</td><td></td></tr>
    <tr><td class="paramname">buffer</td><td>Scratch space for the parser to use internally; input data is consumed and fed to this buffer. Cannot be NULL. </td></tr>
    <tr><td class="paramname">buffer_size</td><td>Size of buffer, in bytes. </td></tr>
    <tr><td class="paramname">callback</td><td>A function to be called when a valid packet is identified. It will be passed an optional user-supplied parameter, a pointer to the packet, and the time the first byte was parsed. </td></tr>
    <tr><td class="paramname">callback_object</td><td>An optional user-specified pointer which is directly passed to the callback as the first parameter. </td></tr>
    <tr><td class="paramname">timeout</td><td>The timeout for receiving one packet. Depends on the serial baud rate and is typically 100 milliseconds. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab846b0b808bbc5b6e24381d13fbda256"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab846b0b808bbc5b6e24381d13fbda256">&#9670;&nbsp;</a></span>mip_parser_last_packet_timestamp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemip_1_1C.html#a8a24a1913ffba77cdd608c5fb7575f37">mip_timestamp</a> mip::C::mip_parser_last_packet_timestamp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmip_1_1C_1_1mip__parser.html">mip_parser</a> *&#160;</td>
          <td class="paramname"><em>parser</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the timestamp of the last parsed packet. </p>
<p>This is only valid after a valid packet has been parsed.</p>
<p>This function is provided to allow additional calls to <a class="el" href="group__mip__parser__c.html#gaef053e67bd8b8e8398b863818a3fc270" title="Parses packets from the input data buffer.">mip_parser_parse()</a> with no input data (buffer=NULL and length=0) when max_packets &gt; 0. The additional calls can use the same timestamp because no new data will be processed.</p>
<p>There are two possible situations after the last call to parse:</p><ol type="1">
<li>Either max_packets was reached, meaning at least one packet was parsed, and thus the timestamp is valid, or</li>
<li>More data is required, in which case this time may not be valid, but it won't matter because an additional call to parse won't produce a new packet to be timestamped. </li>
</ol>

</div>
</div>
<a id="gaef053e67bd8b8e8398b863818a3fc270"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaef053e67bd8b8e8398b863818a3fc270">&#9670;&nbsp;</a></span>mip_parser_parse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t mip::C::mip_parser_parse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmip_1_1C_1_1mip__parser.html">mip_parser</a> *&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>input_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>input_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemip_1_1C.html#a8a24a1913ffba77cdd608c5fb7575f37">mip_timestamp</a>&#160;</td>
          <td class="paramname"><em>timestamp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>max_packets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses packets from the input data buffer. </p>
<p>For every valid MIP packet, the callback function will be called with the packet and timestamp.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parser</td><td></td></tr>
    <tr><td class="paramname">input_buffer</td><td>Pointer to bytes received from the device or file. This buffer may contain non-mip data (e.g. NMEA 0183), which will be ignored. This buffer may be NULL if input_count is 0. </td></tr>
    <tr><td class="paramname">input_count</td><td>The number of bytes in the input buffer. </td></tr>
    <tr><td class="paramname">timestamp</td><td>The local time the data was received. This is used to check for timeouts and is passed to the callback as the packet timestamp. </td></tr>
    <tr><td class="paramname">max_packets</td><td>The maximum number of packets to process. Unprocessed data is left in the internal buffer. If 0, processing runs until no complete packets remain in the buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes left unprocessed from the input buffer. If max_packets is 0, this will also be zero as all of the data will be consumed. Data may still remain in the internal buffer.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If max_packets is 0, then this function is guaranteed to consume all of the input data and the buffer can be reused or discarded afterward. However, if max_packets is nonzero (meaning the number of packets parsed will be limited), then this is no longer guaranteed as the excess data may fill up the internal bufffer. In this case, you must process packets faster than they arrive on average. For bursty data (e.g. GNSS data), use a large internal buffer (see mip_parser_init) to help average out the packet processing load.</dd>
<dd>
The timestamp of parsed packets is based on the time the packet was parsed. When max_packets==0, this is the same as the input timestamp. When max_packets!=0, packets received during an earlier parse call may be timestamped with the time from a later parse call. Therefore, if packet timestamping is critical to your application, avoid using max_packets &gt; 0.</dd>
<dd>
The parser will do its best to ignore non-MIP data. However, it is possible for some binary data to appear to be a MIP packet if it conntains 0x75,0x65, has at least 6 bytes, and has a valid checksum. A 16-bit checksum has a 1 in 65,536 chance of appearing to be valid. </dd></dl>

</div>
</div>
<a id="ga928471c1dbd07ae1c414b3159f78c609"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga928471c1dbd07ae1c414b3159f78c609">&#9670;&nbsp;</a></span>mip_parser_parse_one_packet_from_ring()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mip::C::mip_parser_parse_one_packet_from_ring </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmip_1_1C_1_1mip__parser.html">mip_parser</a> *&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmip_1_1C_1_1mip__packet__view.html">mip_packet_view</a> *&#160;</td>
          <td class="paramname"><em>packet_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemip_1_1C.html#a8a24a1913ffba77cdd608c5fb7575f37">mip_timestamp</a>&#160;</td>
          <td class="paramname"><em>timestamp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses a single packet from the internal buffer. </p>

</div>
</div>
<a id="ga2d3b5a3755b3d2b379f5471fab7e3657"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2d3b5a3755b3d2b379f5471fab7e3657">&#9670;&nbsp;</a></span>mip_parser_process_written()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mip::C::mip_parser_process_written </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmip_1_1C_1_1mip__parser.html">mip_parser</a> *&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemip_1_1C.html#a8a24a1913ffba77cdd608c5fb7575f37">mip_timestamp</a>&#160;</td>
          <td class="paramname"><em>timestamp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>max_packets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Notify the parser that data has been written to the pointer previously obtained via <a class="el" href="group__mip__parser__c.html#ga5ea8146c52227b0f5b5edd091ba4fa38" title="Obtain a pointer into which data may be read for processing.">mip_parser_get_write_ptr()</a>. </p>
<p>The write pointer changes after calling this with count &gt; 0. To write more data, call mip_parser_get_write_ptr again.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parser</td><td></td></tr>
    <tr><td class="paramname">count</td><td></td></tr>
    <tr><td class="paramname">timestamp</td><td></td></tr>
    <tr><td class="paramname">max_packets</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0a0efb3d8c6af48d3141b69d763c916f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0a0efb3d8c6af48d3141b69d763c916f">&#9670;&nbsp;</a></span>mip_parser_reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mip::C::mip_parser_reset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmip_1_1C_1_1mip__parser.html">mip_parser</a> *&#160;</td>
          <td class="paramname"><em>parser</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resets the MIP parser. </p>
<p>Clears the current packet and internal buffer. The parser will be restored as if mip_parser_init had just been called.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parser</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae4d87fe00549f44a43fc835eeae3d7b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae4d87fe00549f44a43fc835eeae3d7b6">&#9670;&nbsp;</a></span>mip_parser_set_callback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mip::C::mip_parser_set_callback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmip_1_1C_1_1mip__parser.html">mip_parser</a> *&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mip__parser__c.html#ga03a7f91bb53f364bbd14c6db26c7617f">mip_packet_callback</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>callback_object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>mip_parser_set_callback </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parser</td><td></td></tr>
    <tr><td class="paramname">callback</td><td></td></tr>
    <tr><td class="paramname">callback_object</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac6af81c0668e6636fa596e7cab977322"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac6af81c0668e6636fa596e7cab977322">&#9670;&nbsp;</a></span>mip_parser_set_timeout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mip::C::mip_parser_set_timeout </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmip_1_1C_1_1mip__parser.html">mip_parser</a> *&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemip_1_1C.html#a8a24a1913ffba77cdd608c5fb7575f37">mip_timestamp</a>&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Changes the timeout of the MIP parser. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parser</td><td></td></tr>
    <tr><td class="paramname">timeout</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6ec005011b45ab2e1d02ac6fb4ba38e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6ec005011b45ab2e1d02ac6fb4ba38e8">&#9670;&nbsp;</a></span>mip_parser_timeout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemip_1_1C.html#aeb7a010ab523fc31b023122aa9b8e524">mip_timeout</a> mip::C::mip_parser_timeout </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmip_1_1C_1_1mip__parser.html">mip_parser</a> *&#160;</td>
          <td class="paramname"><em>parser</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the packet timeout of the parser. </p>

</div>
</div>
<a id="ga519bccb69b9fff2cb3bc8bed2cbcc1f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga519bccb69b9fff2cb3bc8bed2cbcc1f3">&#9670;&nbsp;</a></span>mip_timeout_from_baudrate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemip_1_1C.html#aeb7a010ab523fc31b023122aa9b8e524">mip_timeout</a> mip::C::mip_timeout_from_baudrate </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baudrate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes an appropriate packet timeout for a given serial baud rate. </p>
<dl class="section note"><dt>Note</dt><dd>This function assumes a standard serial port with 10 symbols per byte: 1 start bit, 8 data bits, and 1 stop bit.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baudrate</td><td>Serial baud rate in bits per second</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A timeout value in ms representing the time it would take to transmit a single mip packet of maximum size at the given baud rate, plus some tolerance. </dd></dl>

</div>
</div>
</div><!-- contents -->
<div class="ttc" id="agroup__mip__parser__c_html_ga2d3b5a3755b3d2b379f5471fab7e3657"><div class="ttname"><a href="group__mip__parser__c.html#ga2d3b5a3755b3d2b379f5471fab7e3657">mip::C::mip_parser_process_written</a></div><div class="ttdeci">void mip_parser_process_written(mip_parser *parser, size_t count, mip_timestamp timestamp, unsigned int max_packets)</div><div class="ttdoc">Notify the parser that data has been written to the pointer previously obtained via mip_parser_get_wr...</div><div class="ttdef"><b>Definition:</b> mip_parser.c:387</div></div>
<div class="ttc" id="agroup__mip__parser__c_html_ga5ea8146c52227b0f5b5edd091ba4fa38"><div class="ttname"><a href="group__mip__parser__c.html#ga5ea8146c52227b0f5b5edd091ba4fa38">mip::C::mip_parser_get_write_ptr</a></div><div class="ttdeci">size_t mip_parser_get_write_ptr(mip_parser *parser, uint8_t **const ptr_out)</div><div class="ttdoc">Obtain a pointer into which data may be read for processing.</div><div class="ttdef"><b>Definition:</b> mip_parser.c:368</div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
