<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MIP_SDK: MicroStrain Strings [CPP]</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MIP_SDK
   &#160;<span id="projectnumber">v3.0.0-734-g6d224267</span>
   </div>
   <div id="projectbrief">MicroStrain Communications Library for embedded systems</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">MicroStrain Strings [CPP]<div class="ingroups"><a class="el" href="group__microstrain.html">MicroStrain API</a> &raquo; <a class="el" href="group__microstrain__strings.html">MicroStrain Strings</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>String manipulation in C++.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga0df777fa492644345944839e86bf69c1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__microstrain__strings__cpp.html#ga0df777fa492644345944839e86bf69c1">microstrain::strings::concat</a> (<a class="el" href="namespacemicrostrain.html#a713e840c6a8f0fd7e825a125ee6dae28">CharArrayView</a> buffer, size_t *index, const char *str, size_t len)</td></tr>
<tr class="memdesc:ga0df777fa492644345944839e86bf69c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenate a string into a buffer.  <a href="group__microstrain__strings__cpp.html#ga0df777fa492644345944839e86bf69c1">More...</a><br /></td></tr>
<tr class="separator:ga0df777fa492644345944839e86bf69c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c52341b492cdfc134355dd67094e389"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__microstrain__strings__cpp.html#ga1c52341b492cdfc134355dd67094e389">microstrain::strings::concat</a> (<a class="el" href="namespacemicrostrain.html#a713e840c6a8f0fd7e825a125ee6dae28">CharArrayView</a> buffer, size_t *index, <a class="el" href="namespacemicrostrain.html#a036b8995c523e18903d6f9bc5779242d">ConstCharArrayView</a> str)</td></tr>
<tr class="memdesc:ga1c52341b492cdfc134355dd67094e389"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenate an array of characters into a buffer.  <a href="group__microstrain__strings__cpp.html#ga1c52341b492cdfc134355dd67094e389">More...</a><br /></td></tr>
<tr class="separator:ga1c52341b492cdfc134355dd67094e389"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac906f839a11344ac927448684a104538"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__microstrain__strings__cpp.html#gac906f839a11344ac927448684a104538">microstrain::strings::concat_cstr</a> (<a class="el" href="namespacemicrostrain.html#a713e840c6a8f0fd7e825a125ee6dae28">CharArrayView</a> buffer, size_t *index, const char *str, size_t maxLen=size_t(-1))</td></tr>
<tr class="memdesc:gac906f839a11344ac927448684a104538"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenate a NULL-terminated <a class="el" href="namespacemicrostrain_1_1C.html">C</a> string into a buffer.  <a href="group__microstrain__strings__cpp.html#gac906f839a11344ac927448684a104538">More...</a><br /></td></tr>
<tr class="separator:gac906f839a11344ac927448684a104538"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf0ff687464a22078bbb3e4506a536a5c"><td class="memTemplParams" colspan="2">template&lt;size_t N&gt; </td></tr>
<tr class="memitem:gaf0ff687464a22078bbb3e4506a536a5c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__microstrain__strings__cpp.html#gaf0ff687464a22078bbb3e4506a536a5c">microstrain::strings::concat_l</a> (<a class="el" href="namespacemicrostrain.html#a713e840c6a8f0fd7e825a125ee6dae28">CharArrayView</a> buffer, size_t *index, const char(&amp;str)[N])</td></tr>
<tr class="memdesc:gaf0ff687464a22078bbb3e4506a536a5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenate a string literal into a buffer.  <a href="group__microstrain__strings__cpp.html#gaf0ff687464a22078bbb3e4506a536a5c">More...</a><br /></td></tr>
<tr class="separator:gaf0ff687464a22078bbb3e4506a536a5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba866a6b24d0bd9f4da1cc4a39c2ff3d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__microstrain__strings__cpp.html#gaba866a6b24d0bd9f4da1cc4a39c2ff3d">microstrain::strings::bytesToHexStr</a> (<a class="el" href="namespacemicrostrain.html#a713e840c6a8f0fd7e825a125ee6dae28">CharArrayView</a> buffer, size_t *index, <a class="el" href="namespacemicrostrain.html#ad10904b5b78aab3f27f0a6fa165d94bc">ConstU8ArrayView</a> data, unsigned int byte_grouping)</td></tr>
<tr class="memdesc:gaba866a6b24d0bd9f4da1cc4a39c2ff3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Formats a byte array to a text buffer in hexadecimal.  <a href="group__microstrain__strings__cpp.html#gaba866a6b24d0bd9f4da1cc4a39c2ff3d">More...</a><br /></td></tr>
<tr class="separator:gaba866a6b24d0bd9f4da1cc4a39c2ff3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga0df777fa492644345944839e86bf69c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0df777fa492644345944839e86bf69c1">&#9670;&nbsp;</a></span>concat() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool microstrain::strings::concat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemicrostrain.html#a713e840c6a8f0fd7e825a125ee6dae28">CharArrayView</a>&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">buffer</td><td>Buffer of characters. The size should be the number of characters, including the NULL terminator, that will fit in the buffer. If the pointer is NULL and size is 0, this function will just compute the required buffer size and not write any characters. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">index</td><td>Position in buffer where string data will be written. It will be updated with the new index in all cases. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">str</td><td>String to be appended. Cannot be NULL unless str_len is 0. Does NOT require NULL termination, and any such termination is ignored. NULL characters will be appended just like any other character. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">str_len</td><td>Length of string (number of characters to copy). Usually you would set this to strlen(str). This overrides any NULL terminator in str.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if sufficient buffer space exists or if buffer is NULL. </dd>
<dd>
False if buffer is not NULL and insufficient space is available. </dd></dl>

</div>
</div>
<a id="ga1c52341b492cdfc134355dd67094e389"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1c52341b492cdfc134355dd67094e389">&#9670;&nbsp;</a></span>concat() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool microstrain::strings::concat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemicrostrain.html#a713e840c6a8f0fd7e825a125ee6dae28">CharArrayView</a>&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemicrostrain.html#a036b8995c523e18903d6f9bc5779242d">ConstCharArrayView</a>&#160;</td>
          <td class="paramname"><em>str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Equivalent to <code>concat(buffer, buffer_size, index, str.data(), str.size());</code>. This version accepts a Span of characters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">buffer</td><td>Buffer of characters. The size should be the number of characters, including the NULL terminator, that will fit in the buffer. If the pointer is NULL and size is 0, this function will just compute the required buffer size and not write any characters. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">index</td><td>Position in buffer where string data will be written. It will be updated with the new index in all cases. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">str</td><td>String to be appended. Embedded NULL chars are allowed; Use concat_z for strings which are terminated before the end of the span.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if sufficient buffer space exists or if buffer is NULL. </dd>
<dd>
False if buffer is not NULL and insufficient space is available. </dd></dl>

</div>
</div>
<a id="gac906f839a11344ac927448684a104538"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac906f839a11344ac927448684a104538">&#9670;&nbsp;</a></span>concat_cstr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool microstrain::strings::concat_cstr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemicrostrain.html#a713e840c6a8f0fd7e825a125ee6dae28">CharArrayView</a>&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxLen</em> = <code>size_t(-1)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Equivalent to <code>concat(buffer, buffer_size, index, str, strlen(str));</code>.</p>
<p>Copies up to <code>maxLen</code> characters, or the first NULL character is reached, whichever comes first. maxLen can be used when it's uncertain if the source buffer is properly terminated.</p>
<p>Examples: </p><div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span>* str = <span class="stringliteral">&quot;To be appended&quot;</span>;</div>
<div class="line">concat_z(buffer, &amp;index, str);    <span class="comment">// NULL-terminated, no maxlen</span></div>
<div class="line">concat_z(buffer, &amp;index, str, 5); <span class="comment">// Only copies &quot;To be&quot;</span></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">buffer</td><td>Buffer of characters. The size should be the number of characters, including the NULL terminator, that will fit in the buffer. If the pointer is NULL and size is 0, this function will just compute the required buffer size and not write any characters. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">index</td><td>Position in buffer where string data will be written. It will be updated with the new index in all cases. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">str</td><td>String to be appended. NULL-termination is required unless maxLen is given. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">maxLen</td><td>If given, limit to this many characters. Defaults to unlimited.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if sufficient buffer space exists or if buffer is NULL. </dd>
<dd>
False if buffer is not NULL and insufficient space is available. </dd></dl>

</div>
</div>
<a id="gaf0ff687464a22078bbb3e4506a536a5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf0ff687464a22078bbb3e4506a536a5c">&#9670;&nbsp;</a></span>concat_l()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool microstrain::strings::concat_l </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemicrostrain.html#a713e840c6a8f0fd7e825a125ee6dae28">CharArrayView</a>&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char(&amp;)&#160;</td>
          <td class="paramname"><em>str</em>[N]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Equivalent to <code>concat(buffer, buffer_size, index, str, sizeof(str)-1);</code>.</p>
<p>Use this by passing a string literal directly so that the compiler is able to deduce the size of the string. This avoids the need to call std::strlen.</p>
<p>Example: <code>concat_l(buffer, &amp;index, "append this string");</code></p>
<p>Note that this also works with <a class="el" href="namespacemicrostrain_1_1C.html">C</a> arrays, in which case the entire array is appended (NULLs and all).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">buffer</td><td>Buffer of characters. The size should be the number of characters, including the NULL terminator, that will fit in the buffer. If the pointer is NULL and size is 0, this function will just compute the required buffer size and not write any characters. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">index</td><td>Position in buffer where string data will be written. It will be updated with the new index in all cases. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">str</td><td>String to be appended. Embedded NULL chars are allowed. Use concat_z for strings which are terminated before N characters.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if sufficient buffer space exists or if buffer is NULL. </dd>
<dd>
False if buffer is not NULL and insufficient space is available. </dd></dl>

</div>
</div>
<a id="gaba866a6b24d0bd9f4da1cc4a39c2ff3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaba866a6b24d0bd9f4da1cc4a39c2ff3d">&#9670;&nbsp;</a></span>bytesToHexStr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool microstrain::strings::bytesToHexStr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemicrostrain.html#a713e840c6a8f0fd7e825a125ee6dae28">CharArrayView</a>&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemicrostrain.html#ad10904b5b78aab3f27f0a6fa165d94bc">ConstU8ArrayView</a>&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>byte_grouping</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>No additional characters are printed other than the hex values and spaces (if byte_grouping is positive). No leading or trailing space is printed.</p>
<p>Examples: </p><div class="fragment"></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">buffer</td><td>Buffer of characters. The size should be the number of characters, including the NULL terminator, that will fit in the buffer. If the pointer is NULL and size is 0, this function will just compute the required buffer size and not write any characters. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">index</td><td>Position in buffer where string data will be written. It will be updated with the new index and will point to the new NULL terminator position. If insufficient space is available in buffer, index will still be updated even if it exceeds buffer_size. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">data</td><td>Data to be formatted. Can be NULL if data_size is 0. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">data_size</td><td>Number of bytes from data to print. Must be 0 if data is NULL. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">byte_grouping</td><td>If greater than zero, a space will be printed every byte_grouping bytes. E.g. a group of 2 will print pairs of bytes separated by spaces.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if successful </dd>
<dd>
False if an encoding error occurs (see snprintf). The index is unchanged in this case. </dd>
<dd>
False if insufficient space is available, unless buffer is NULL. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
