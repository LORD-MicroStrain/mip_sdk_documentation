<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MIP_SDK: MicroStrain Strings [CPP]</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MIP_SDK
   &#160;<span id="projectnumber">v3.0.0-425-g6df21bd</span>
   </div>
   <div id="projectbrief">MicroStrain Communications Library for embedded systems</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">MicroStrain Strings [CPP]<div class="ingroups"><a class="el" href="group__microstrain.html">MicroStrain API</a> &raquo; <a class="el" href="group__microstrain__strings.html">MicroStrain Strings</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>String manipulation in C++.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga9a7ce50b977c44b1c20b4dfe80c38362"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__microstrain__strings__cpp.html#ga9a7ce50b977c44b1c20b4dfe80c38362">microstrain::strings::concat</a> (<a class="el" href="structmicrostrain_1_1Span.html">Span</a>&lt; char &gt; buffer, size_t *index, const char *str, size_t len)</td></tr>
<tr class="memdesc:ga9a7ce50b977c44b1c20b4dfe80c38362"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenate a string into a buffer.  <a href="group__microstrain__strings__cpp.html#ga9a7ce50b977c44b1c20b4dfe80c38362">More...</a><br /></td></tr>
<tr class="separator:ga9a7ce50b977c44b1c20b4dfe80c38362"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e007e5b90eae6a7b1396c4a6ff87ac8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__microstrain__strings__cpp.html#ga6e007e5b90eae6a7b1396c4a6ff87ac8">microstrain::strings::concat</a> (<a class="el" href="structmicrostrain_1_1Span.html">Span</a>&lt; char &gt; buffer, size_t *index, <a class="el" href="structmicrostrain_1_1Span.html">Span</a>&lt; const char &gt; str)</td></tr>
<tr class="memdesc:ga6e007e5b90eae6a7b1396c4a6ff87ac8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenate an array of characters into a buffer.  <a href="group__microstrain__strings__cpp.html#ga6e007e5b90eae6a7b1396c4a6ff87ac8">More...</a><br /></td></tr>
<tr class="separator:ga6e007e5b90eae6a7b1396c4a6ff87ac8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae8fc6b138683c6e4320cbe7a145102ec"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__microstrain__strings__cpp.html#gae8fc6b138683c6e4320cbe7a145102ec">microstrain::strings::concat_z</a> (<a class="el" href="structmicrostrain_1_1Span.html">Span</a>&lt; char &gt; buffer, size_t *index, const char *str, size_t maxLen=size_t(-1))</td></tr>
<tr class="memdesc:gae8fc6b138683c6e4320cbe7a145102ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenate a NULL-terminated <a class="el" href="namespacemicrostrain_1_1C.html">C</a> string into a buffer.  <a href="group__microstrain__strings__cpp.html#gae8fc6b138683c6e4320cbe7a145102ec">More...</a><br /></td></tr>
<tr class="separator:gae8fc6b138683c6e4320cbe7a145102ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga435b5dd122d84d2ce56e5ba988dfb203"><td class="memTemplParams" colspan="2">template&lt;size_t N&gt; </td></tr>
<tr class="memitem:ga435b5dd122d84d2ce56e5ba988dfb203"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__microstrain__strings__cpp.html#ga435b5dd122d84d2ce56e5ba988dfb203">microstrain::strings::concat_l</a> (<a class="el" href="structmicrostrain_1_1Span.html">Span</a>&lt; char &gt; buffer, size_t *index, const char(&amp;str)[N])</td></tr>
<tr class="memdesc:ga435b5dd122d84d2ce56e5ba988dfb203"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenate a string literal into a buffer.  <a href="group__microstrain__strings__cpp.html#ga435b5dd122d84d2ce56e5ba988dfb203">More...</a><br /></td></tr>
<tr class="separator:ga435b5dd122d84d2ce56e5ba988dfb203"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga621aff4861f17936a80fd3d972af0707"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__microstrain__strings__cpp.html#ga621aff4861f17936a80fd3d972af0707">microstrain::strings::format_v</a> (<a class="el" href="structmicrostrain_1_1Span.html">Span</a>&lt; char &gt; buffer, size_t *index, const char *fmt, va_list args)</td></tr>
<tr class="memdesc:ga621aff4861f17936a80fd3d972af0707"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for std::vsnprintf with a better interface.  <a href="group__microstrain__strings__cpp.html#ga621aff4861f17936a80fd3d972af0707">More...</a><br /></td></tr>
<tr class="separator:ga621aff4861f17936a80fd3d972af0707"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76ef39c44a3a284f295f7637ecc104c0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__microstrain__strings__cpp.html#ga76ef39c44a3a284f295f7637ecc104c0">microstrain::strings::format</a> (<a class="el" href="structmicrostrain_1_1Span.html">Span</a>&lt; char &gt; buffer, size_t *index, const char *fmt,...)</td></tr>
<tr class="memdesc:ga76ef39c44a3a284f295f7637ecc104c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for std::snprintf with a better interface.  <a href="group__microstrain__strings__cpp.html#ga76ef39c44a3a284f295f7637ecc104c0">More...</a><br /></td></tr>
<tr class="separator:ga76ef39c44a3a284f295f7637ecc104c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6ed00dc8e4a45abc0f082b5417ea3e8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__microstrain__strings__cpp.html#gae6ed00dc8e4a45abc0f082b5417ea3e8">microstrain::strings::bytesToHexStr</a> (<a class="el" href="structmicrostrain_1_1Span.html">Span</a>&lt; char &gt; buffer, size_t *index, <a class="el" href="structmicrostrain_1_1Span.html">Span</a>&lt; const uint8_t &gt; data, unsigned int byte_grouping)</td></tr>
<tr class="memdesc:gae6ed00dc8e4a45abc0f082b5417ea3e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Formats a byte array to a text buffer in hexadecimal.  <a href="group__microstrain__strings__cpp.html#gae6ed00dc8e4a45abc0f082b5417ea3e8">More...</a><br /></td></tr>
<tr class="separator:gae6ed00dc8e4a45abc0f082b5417ea3e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>String manipulation in C++. </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="gae6ed00dc8e4a45abc0f082b5417ea3e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae6ed00dc8e4a45abc0f082b5417ea3e8">&#9670;&nbsp;</a></span>bytesToHexStr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool microstrain::strings::bytesToHexStr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmicrostrain_1_1Span.html">Span</a>&lt; char &gt;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmicrostrain_1_1Span.html">Span</a>&lt; const uint8_t &gt;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>byte_grouping</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Formats a byte array to a text buffer in hexadecimal. </p>
<p>No additional characters are printed other than the hex values and spaces (if byte_grouping is positive). No leading or trailing space is printed.</p>
<p>Examples: </p><div class="fragment"></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">buffer</td><td>Buffer of characters. The size should be the number of characters, including the NULL terminator, that will fit in the buffer. If the pointer is NULL and size is 0, this function will just compute the required buffer size and not write any characters. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">index</td><td>Position in buffer where string data will be written. It will be updated with the new index and will point to the new NULL terminator position. If insufficient space is available in buffer, index will still be updated even if it exceeds buffer_size. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">data</td><td>Data to be formatted. Can be NULL if data_size is 0. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">data_size</td><td>Number of bytes from data to print. Must be 0 if data is NULL. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">byte_grouping</td><td>If greater than zero, a space will be printed every byte_grouping bytes. E.g. a group of 2 will print pairs of bytes separated by spaces.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if successful </dd>
<dd>
False if an encoding error occurs (see snprintf). The index is unchanged in this case. </dd>
<dd>
False if insufficient space is available, unless buffer is NULL. </dd></dl>

</div>
</div>
<a id="ga9a7ce50b977c44b1c20b4dfe80c38362"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9a7ce50b977c44b1c20b4dfe80c38362">&#9670;&nbsp;</a></span>concat() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool microstrain::strings::concat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmicrostrain_1_1Span.html">Span</a>&lt; char &gt;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Concatenate a string into a buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">buffer</td><td>Buffer of characters. The size should be the number of characters, including the NULL terminator, that will fit in the buffer. If the pointer is NULL and size is 0, this function will just compute the required buffer size and not write any characters. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">index</td><td>Position in buffer where string data will be written. It will be updated with the new index in all cases. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">str</td><td>String to be appended. Cannot be NULL unless str_len is 0. Does NOT require NULL termination, and any such termination is ignored. NULL characters will be appended just like any other character. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">str_len</td><td>Length of string (number of characters to copy). Usually you would set this to strlen(str). This overrides any NULL terminator in str.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if sufficient buffer space exists or if buffer is NULL. </dd>
<dd>
False if buffer is not NULL and insufficient space is available. </dd></dl>

</div>
</div>
<a id="ga6e007e5b90eae6a7b1396c4a6ff87ac8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6e007e5b90eae6a7b1396c4a6ff87ac8">&#9670;&nbsp;</a></span>concat() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool microstrain::strings::concat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmicrostrain_1_1Span.html">Span</a>&lt; char &gt;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmicrostrain_1_1Span.html">Span</a>&lt; const char &gt;&#160;</td>
          <td class="paramname"><em>str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Concatenate an array of characters into a buffer. </p>
<p>Equivalent to <code>concat(buffer, buffer_size, index, str.data(), str.size());</code>. This version accepts a <a class="el" href="structmicrostrain_1_1Span.html" title="Implementation of std::span from C++20.">Span</a> of characters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">buffer</td><td>Buffer of characters. The size should be the number of characters, including the NULL terminator, that will fit in the buffer. If the pointer is NULL and size is 0, this function will just compute the required buffer size and not write any characters. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">index</td><td>Position in buffer where string data will be written. It will be updated with the new index in all cases. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">str</td><td>String to be appended. Embedded NULL chars are allowed; Use concat_z for strings which are terminated before the end of the span.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if sufficient buffer space exists or if buffer is NULL. </dd>
<dd>
False if buffer is not NULL and insufficient space is available. </dd></dl>

</div>
</div>
<a id="ga435b5dd122d84d2ce56e5ba988dfb203"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga435b5dd122d84d2ce56e5ba988dfb203">&#9670;&nbsp;</a></span>concat_l()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool microstrain::strings::concat_l </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmicrostrain_1_1Span.html">Span</a>&lt; char &gt;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char(&amp;)&#160;</td>
          <td class="paramname"><em>str</em>[N]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Concatenate a string literal into a buffer. </p>
<p>Equivalent to <code>concat(buffer, buffer_size, index, str, sizeof(str)-1);</code>.</p>
<p>Use this by passing a string literal directly so that the compiler is able to deduce the size of the string. This avoids the need to call std::strlen.</p>
<p>Example: <code>concat_l(buffer, &amp;index, "append this string");</code></p>
<p>Note that this also works with <a class="el" href="namespacemicrostrain_1_1C.html">C</a> arrays, in which case the entire array is appended (NULLs and all).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">buffer</td><td>Buffer of characters. The size should be the number of characters, including the NULL terminator, that will fit in the buffer. If the pointer is NULL and size is 0, this function will just compute the required buffer size and not write any characters. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">index</td><td>Position in buffer where string data will be written. It will be updated with the new index in all cases. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">str</td><td>String to be appended. Embedded NULL chars are allowed. Use concat_z for strings which are terminated before N characters.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if sufficient buffer space exists or if buffer is NULL. </dd>
<dd>
False if buffer is not NULL and insufficient space is available. </dd></dl>

</div>
</div>
<a id="gae8fc6b138683c6e4320cbe7a145102ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae8fc6b138683c6e4320cbe7a145102ec">&#9670;&nbsp;</a></span>concat_z()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool microstrain::strings::concat_z </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmicrostrain_1_1Span.html">Span</a>&lt; char &gt;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxLen</em> = <code>size_t(-1)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Concatenate a NULL-terminated <a class="el" href="namespacemicrostrain_1_1C.html">C</a> string into a buffer. </p>
<p>Equivalent to <code>concat(buffer, buffer_size, index, str, strlen(str));</code>.</p>
<p>Copies up to <code>maxLen</code> characters, or the first NULL character is reached, whichever comes first. maxLen can be used when it's uncertain if the source buffer is properly terminated.</p>
<p>Examples: </p><div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span>* str = <span class="stringliteral">&quot;To be appended&quot;</span>;</div>
<div class="line"><a class="code" href="group__microstrain__strings__cpp.html#gae8fc6b138683c6e4320cbe7a145102ec">concat_z</a>(buffer, &amp;index, str);    <span class="comment">// NULL-terminated, no maxlen</span></div>
<div class="line"><a class="code" href="group__microstrain__strings__cpp.html#gae8fc6b138683c6e4320cbe7a145102ec">concat_z</a>(buffer, &amp;index, str, 5); <span class="comment">// Only copies &quot;To be&quot;</span></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">buffer</td><td>Buffer of characters. The size should be the number of characters, including the NULL terminator, that will fit in the buffer. If the pointer is NULL and size is 0, this function will just compute the required buffer size and not write any characters. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">index</td><td>Position in buffer where string data will be written. It will be updated with the new index in all cases. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">str</td><td>String to be appended. NULL-termination is required unless maxLen is given. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">maxLen</td><td>If given, limit to this many characters. Defaults to unlimited.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if sufficient buffer space exists or if buffer is NULL. </dd>
<dd>
False if buffer is not NULL and insufficient space is available. </dd></dl>

</div>
</div>
<a id="ga76ef39c44a3a284f295f7637ecc104c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga76ef39c44a3a284f295f7637ecc104c0">&#9670;&nbsp;</a></span>format()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool microstrain::strings::format </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmicrostrain_1_1Span.html">Span</a>&lt; char &gt;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wrapper for std::snprintf with a better interface. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">buffer</td><td>Buffer of characters. The size should be the number of characters, including the NULL terminator, that will fit in the buffer. If the pointer is NULL and size is 0, this function will just compute the required buffer size and not write any characters. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">index</td><td>Position in buffer where string data will be written. It will be updated with the new index and will point to the new NULL terminator position. If insufficient space is available in buffer, index will still be updated even if it exceeds buffer_size. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">fmt</td><td>Format string similar to printf.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if successful </dd>
<dd>
False if an encoding error occurs (see snprintf). The index is unchanged in this case. </dd>
<dd>
False if insufficient space is available, unless buffer is NULL. </dd></dl>

</div>
</div>
<a id="ga621aff4861f17936a80fd3d972af0707"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga621aff4861f17936a80fd3d972af0707">&#9670;&nbsp;</a></span>format_v()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool microstrain::strings::format_v </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmicrostrain_1_1Span.html">Span</a>&lt; char &gt;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">va_list&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wrapper for std::vsnprintf with a better interface. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">buffer</td><td>Buffer of characters. The size should be the number of characters, including the NULL terminator, that will fit in the buffer. If the pointer is NULL and size is 0, this function will just compute the required buffer size and not write any characters. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">index</td><td>Position in buffer where string data will be written. It will be updated with the new index and will point to the new NULL terminator position. If insufficient space is available in buffer, index will still be updated even if it exceeds buffer_size. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">fmt</td><td>Format string similar to printf. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">args</td><td>List of formatting arguments similar to vprintf.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if successful </dd>
<dd>
False if an encoding error occurs (see snprintf). The index is unchanged in this case. </dd>
<dd>
False if insufficient space is available, unless buffer is NULL. </dd></dl>

</div>
</div>
</div><!-- contents -->
<div class="ttc" id="agroup__microstrain__strings__cpp_html_gae8fc6b138683c6e4320cbe7a145102ec"><div class="ttname"><a href="group__microstrain__strings__cpp.html#gae8fc6b138683c6e4320cbe7a145102ec">microstrain::strings::concat_z</a></div><div class="ttdeci">bool concat_z(Span&lt; char &gt; buffer, size_t *index, const char *str, size_t maxLen=size_t(-1))</div><div class="ttdoc">Concatenate a NULL-terminated C string into a buffer.</div><div class="ttdef"><b>Definition:</b> strings.hpp:173</div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
