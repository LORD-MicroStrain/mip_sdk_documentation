<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MIP_SDK: Mip Interface</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MIP_SDK
   &#160;<span id="projectnumber">v3.0.0-187-g93c7302</span>
   </div>
   <div id="projectbrief">MicroStrain Communications Library for embedded systems</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Mip Interface<div class="ingroups"><a class="el" href="group__mip.html">MIP</a> &raquo; <a class="el" href="group__mip__c.html">MIP C API</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>High-level C functions for controlling a MIP device.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmip_1_1C_1_1mip__interface.html">mip::C::mip_interface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">State of the interface for communicating with a MIP device.  <a href="structmip_1_1C_1_1mip__interface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga1ab538fe6a048b11f97174b2f1ecc3de"><td class="memItemLeft" align="right" valign="top">typedef bool(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mip__interface__c.html#ga1ab538fe6a048b11f97174b2f1ecc3de">mip::C::mip_send_callback</a>) (struct <a class="el" href="structmip_1_1C_1_1mip__interface.html">mip_interface</a> *device, const uint8_t *data, size_t length)</td></tr>
<tr class="memdesc:ga1ab538fe6a048b11f97174b2f1ecc3de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called from <a class="el" href="group__mip__interface__c.html#ga04a725bcf412e0c7bc4c7c53b74c5553" title="Sends data to the port (i.e. from this library to the physical device).">mip_interface_send_to_device()</a> to send data to the device port. The application should forward the data to the device port (e.g. a serial port, TCP connection, etc).  <a href="group__mip__interface__c.html#ga1ab538fe6a048b11f97174b2f1ecc3de">More...</a><br /></td></tr>
<tr class="separator:ga1ab538fe6a048b11f97174b2f1ecc3de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c3a2f3d1dd0b7345e46144f83c7d16c"><td class="memItemLeft" align="right" valign="top">typedef bool(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mip__interface__c.html#ga5c3a2f3d1dd0b7345e46144f83c7d16c">mip::C::mip_recv_callback</a>) (struct <a class="el" href="structmip_1_1C_1_1mip__interface.html">mip_interface</a> *device, uint8_t *buffer, size_t max_length, <a class="el" href="namespacemip_1_1C.html#aeb7a010ab523fc31b023122aa9b8e524">mip_timeout</a> wait_time, bool from_cmd, size_t *length_out, <a class="el" href="namespacemip_1_1C.html#a8a24a1913ffba77cdd608c5fb7575f37">mip_timestamp</a> *timestamp_out)</td></tr>
<tr class="memdesc:ga5c3a2f3d1dd0b7345e46144f83c7d16c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called from <a class="el" href="group__mip__interface__c.html#ga556502e5eba49d92af8ee84ed3ae36c0" title="Checks for data at the port and reads it into buffer.">mip_interface_recv_from_device()</a> to receive data from the device port.  <a href="group__mip__interface__c.html#ga5c3a2f3d1dd0b7345e46144f83c7d16c">More...</a><br /></td></tr>
<tr class="separator:ga5c3a2f3d1dd0b7345e46144f83c7d16c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87201ed89cfecf0d2b31a9297bbb93e8"><td class="memItemLeft" align="right" valign="top">typedef bool(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mip__interface__c.html#ga87201ed89cfecf0d2b31a9297bbb93e8">mip::C::mip_update_callback</a>) (struct <a class="el" href="structmip_1_1C_1_1mip__interface.html">mip_interface</a> *device, <a class="el" href="namespacemip_1_1C.html#aeb7a010ab523fc31b023122aa9b8e524">mip_timeout</a> wait_time, bool from_cmd)</td></tr>
<tr class="memdesc:ga87201ed89cfecf0d2b31a9297bbb93e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback function typedef for custom update behavior.  <a href="group__mip__interface__c.html#ga87201ed89cfecf0d2b31a9297bbb93e8">More...</a><br /></td></tr>
<tr class="separator:ga87201ed89cfecf0d2b31a9297bbb93e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad6898733d3e1d41d14a84280c5435fa"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structmip_1_1C_1_1mip__interface.html">mip::C::mip_interface</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mip__interface__c.html#gaad6898733d3e1d41d14a84280c5435fa">mip::C::mip_interface</a></td></tr>
<tr class="memdesc:gaad6898733d3e1d41d14a84280c5435fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">State of the interface for communicating with a MIP device.  <a href="group__mip__interface__c.html#gaad6898733d3e1d41d14a84280c5435fa">More...</a><br /></td></tr>
<tr class="separator:gaad6898733d3e1d41d14a84280c5435fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga38ee5f31ce57f30418fc2a9e3970e082"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mip__interface__c.html#ga38ee5f31ce57f30418fc2a9e3970e082">mip::C::mip_interface_init</a> (<a class="el" href="structmip_1_1C_1_1mip__interface.html">mip_interface</a> *device, <a class="el" href="namespacemip_1_1C.html#aeb7a010ab523fc31b023122aa9b8e524">mip_timeout</a> parse_timeout, <a class="el" href="namespacemip_1_1C.html#aeb7a010ab523fc31b023122aa9b8e524">mip_timeout</a> base_reply_timeout, <a class="el" href="group__mip__interface__c.html#ga1ab538fe6a048b11f97174b2f1ecc3de">mip_send_callback</a> send, <a class="el" href="group__mip__interface__c.html#ga5c3a2f3d1dd0b7345e46144f83c7d16c">mip_recv_callback</a> recv, <a class="el" href="group__mip__interface__c.html#ga87201ed89cfecf0d2b31a9297bbb93e8">mip_update_callback</a> update, void *user_pointer)</td></tr>
<tr class="memdesc:ga38ee5f31ce57f30418fc2a9e3970e082"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the <a class="el" href="structmip_1_1C_1_1mip__interface.html" title="State of the interface for communicating with a MIP device.">mip_interface</a> components.  <a href="group__mip__interface__c.html#ga38ee5f31ce57f30418fc2a9e3970e082">More...</a><br /></td></tr>
<tr class="separator:ga38ee5f31ce57f30418fc2a9e3970e082"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga04a725bcf412e0c7bc4c7c53b74c5553"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mip__interface__c.html#ga04a725bcf412e0c7bc4c7c53b74c5553">mip::C::mip_interface_send_to_device</a> (<a class="el" href="structmip_1_1C_1_1mip__interface.html">mip_interface</a> *device, const uint8_t *data, size_t length)</td></tr>
<tr class="memdesc:ga04a725bcf412e0c7bc4c7c53b74c5553"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends data to the port (i.e. from this library to the physical device).  <a href="group__mip__interface__c.html#ga04a725bcf412e0c7bc4c7c53b74c5553">More...</a><br /></td></tr>
<tr class="separator:ga04a725bcf412e0c7bc4c7c53b74c5553"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga556502e5eba49d92af8ee84ed3ae36c0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mip__interface__c.html#ga556502e5eba49d92af8ee84ed3ae36c0">mip::C::mip_interface_recv_from_device</a> (<a class="el" href="structmip_1_1C_1_1mip__interface.html">mip_interface</a> *device, uint8_t *buffer, size_t max_length, <a class="el" href="namespacemip_1_1C.html#aeb7a010ab523fc31b023122aa9b8e524">mip_timeout</a> wait_time, bool from_cmd, size_t *length_out, <a class="el" href="namespacemip_1_1C.html#a8a24a1913ffba77cdd608c5fb7575f37">mip_timestamp</a> *timestamp_out)</td></tr>
<tr class="memdesc:ga556502e5eba49d92af8ee84ed3ae36c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks for data at the port and reads it into buffer.  <a href="group__mip__interface__c.html#ga556502e5eba49d92af8ee84ed3ae36c0">More...</a><br /></td></tr>
<tr class="separator:ga556502e5eba49d92af8ee84ed3ae36c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc671aab52f5f4281aee67f8453125de"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mip__interface__c.html#gabc671aab52f5f4281aee67f8453125de">mip::C::mip_interface_update</a> (<a class="el" href="structmip_1_1C_1_1mip__interface.html">mip_interface</a> *device, <a class="el" href="namespacemip_1_1C.html#aeb7a010ab523fc31b023122aa9b8e524">mip_timeout</a> wait_time, bool from_cmd)</td></tr>
<tr class="memdesc:gabc671aab52f5f4281aee67f8453125de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call to process data from the device.  <a href="group__mip__interface__c.html#gabc671aab52f5f4281aee67f8453125de">More...</a><br /></td></tr>
<tr class="separator:gabc671aab52f5f4281aee67f8453125de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf35d6a824e64ec29031a219fbeccd99a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mip__interface__c.html#gaf35d6a824e64ec29031a219fbeccd99a">mip::C::mip_interface_default_update</a> (<a class="el" href="structmip_1_1C_1_1mip__interface.html">mip_interface</a> *device, <a class="el" href="namespacemip_1_1C.html#aeb7a010ab523fc31b023122aa9b8e524">mip_timeout</a> wait_time, bool from_cmd)</td></tr>
<tr class="memdesc:gaf35d6a824e64ec29031a219fbeccd99a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Polls the port for new data or command replies.  <a href="group__mip__interface__c.html#gaf35d6a824e64ec29031a219fbeccd99a">More...</a><br /></td></tr>
<tr class="separator:gaf35d6a824e64ec29031a219fbeccd99a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c27a3c0cc93d4372cce72ed49bb3f1b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mip__interface__c.html#ga4c27a3c0cc93d4372cce72ed49bb3f1b">mip::C::mip_interface_default_update_ext_buffer</a> (<a class="el" href="structmip_1_1C_1_1mip__interface.html">mip_interface</a> *device, <a class="el" href="namespacemip_1_1C.html#aeb7a010ab523fc31b023122aa9b8e524">mip_timeout</a> wait_time, bool from_cmd, uint8_t *buffer, size_t buffer_size)</td></tr>
<tr class="memdesc:ga4c27a3c0cc93d4372cce72ed49bb3f1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Polls the port for new data or command replies using a supplied buffer.  <a href="group__mip__interface__c.html#ga4c27a3c0cc93d4372cce72ed49bb3f1b">More...</a><br /></td></tr>
<tr class="separator:ga4c27a3c0cc93d4372cce72ed49bb3f1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2aee551e276ed77732c45a23d0c70b82"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mip__interface__c.html#ga2aee551e276ed77732c45a23d0c70b82">mip::C::mip_interface_input_bytes_andor_time</a> (<a class="el" href="structmip_1_1C_1_1mip__interface.html">mip_interface</a> *device, const uint8_t *received_data, size_t data_length, <a class="el" href="namespacemip_1_1C.html#a8a24a1913ffba77cdd608c5fb7575f37">mip_timestamp</a> now)</td></tr>
<tr class="memdesc:ga2aee551e276ed77732c45a23d0c70b82"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function takes care of processing received data and updating the current time.  <a href="group__mip__interface__c.html#ga2aee551e276ed77732c45a23d0c70b82">More...</a><br /></td></tr>
<tr class="separator:ga2aee551e276ed77732c45a23d0c70b82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga800e3595cd010513a8c0f7a8591c76f3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mip__interface__c.html#ga800e3595cd010513a8c0f7a8591c76f3">mip::C::mip_interface_input_bytes_from_device</a> (<a class="el" href="structmip_1_1C_1_1mip__interface.html">mip_interface</a> *device, const uint8_t *data, size_t length, <a class="el" href="namespacemip_1_1C.html#a8a24a1913ffba77cdd608c5fb7575f37">mip_timestamp</a> timestamp)</td></tr>
<tr class="memdesc:ga800e3595cd010513a8c0f7a8591c76f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Passes data from the device into the parser.  <a href="group__mip__interface__c.html#ga800e3595cd010513a8c0f7a8591c76f3">More...</a><br /></td></tr>
<tr class="separator:ga800e3595cd010513a8c0f7a8591c76f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga211fe6ffec9ce7fb891269068e738ed2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mip__interface__c.html#ga211fe6ffec9ce7fb891269068e738ed2">mip::C::mip_interface_input_packet_from_device</a> (<a class="el" href="structmip_1_1C_1_1mip__interface.html">mip_interface</a> *device, const <a class="el" href="structmip_1_1C_1_1mip__packet__view.html">mip_packet_view</a> *packet, <a class="el" href="namespacemip_1_1C.html#a8a24a1913ffba77cdd608c5fb7575f37">mip_timestamp</a> timestamp)</td></tr>
<tr class="memdesc:ga211fe6ffec9ce7fb891269068e738ed2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Processes a pre-parsed packet for command replies and data.  <a href="group__mip__interface__c.html#ga211fe6ffec9ce7fb891269068e738ed2">More...</a><br /></td></tr>
<tr class="separator:ga211fe6ffec9ce7fb891269068e738ed2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44b0500ae8cf2809f934893e2e47b8ce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mip__interface__c.html#ga44b0500ae8cf2809f934893e2e47b8ce">mip::C::mip_interface_update_time</a> (<a class="el" href="structmip_1_1C_1_1mip__interface.html">mip_interface</a> *device, <a class="el" href="namespacemip_1_1C.html#a8a24a1913ffba77cdd608c5fb7575f37">mip_timestamp</a> timestamp)</td></tr>
<tr class="memdesc:ga44b0500ae8cf2809f934893e2e47b8ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call this to ensure that pending commands time out properly.  <a href="group__mip__interface__c.html#ga44b0500ae8cf2809f934893e2e47b8ce">More...</a><br /></td></tr>
<tr class="separator:ga44b0500ae8cf2809f934893e2e47b8ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga15f97e860ab600fe3982e4ad5b289d65"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mip__interface__c.html#ga15f97e860ab600fe3982e4ad5b289d65">mip::C::mip_interface_parse_callback</a> (void *device, const <a class="el" href="structmip_1_1C_1_1mip__packet__view.html">mip_packet_view</a> *packet, <a class="el" href="namespacemip_1_1C.html#a8a24a1913ffba77cdd608c5fb7575f37">mip_timestamp</a> timestamp)</td></tr>
<tr class="memdesc:ga15f97e860ab600fe3982e4ad5b289d65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper around mip_interface_input_packet_from_device for use with <a class="el" href="structmip_1_1C_1_1mip__parser.html" title="MIP Parser state.">mip_parser</a>.  <a href="group__mip__interface__c.html#ga15f97e860ab600fe3982e4ad5b289d65">More...</a><br /></td></tr>
<tr class="separator:ga15f97e860ab600fe3982e4ad5b289d65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaaedad73f9ab28beb69e2a1a8c9da636"><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="group__mip__c.html#gab3f1cea4c06739d4530f7d8088bd3ed8">mip_cmd_result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mip__interface__c.html#gaaaedad73f9ab28beb69e2a1a8c9da636">mip::C::mip_interface_wait_for_reply</a> (<a class="el" href="structmip_1_1C_1_1mip__interface.html">mip_interface</a> *device, <a class="el" href="structmip_1_1C_1_1mip__pending__cmd.html">mip_pending_cmd</a> *cmd)</td></tr>
<tr class="memdesc:gaaaedad73f9ab28beb69e2a1a8c9da636"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocks until the pending command completes or times out.  <a href="group__mip__interface__c.html#gaaaedad73f9ab28beb69e2a1a8c9da636">More...</a><br /></td></tr>
<tr class="separator:gaaaedad73f9ab28beb69e2a1a8c9da636"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4528ffd3e7252186568648cae4fece8c"><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="group__mip__c.html#gab3f1cea4c06739d4530f7d8088bd3ed8">mip_cmd_result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mip__interface__c.html#ga4528ffd3e7252186568648cae4fece8c">mip::C::mip_interface_run_command</a> (<a class="el" href="structmip_1_1C_1_1mip__interface.html">mip_interface</a> *device, uint8_t descriptor_set, uint8_t cmd_descriptor, const uint8_t *cmd_data, uint8_t cmd_length)</td></tr>
<tr class="memdesc:ga4528ffd3e7252186568648cae4fece8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runs a command using a pre-serialized payload.  <a href="group__mip__interface__c.html#ga4528ffd3e7252186568648cae4fece8c">More...</a><br /></td></tr>
<tr class="separator:ga4528ffd3e7252186568648cae4fece8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8167db65f8a63ecf98e2e378b75e242"><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="group__mip__c.html#gab3f1cea4c06739d4530f7d8088bd3ed8">mip_cmd_result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mip__interface__c.html#gaa8167db65f8a63ecf98e2e378b75e242">mip::C::mip_interface_run_command_with_response</a> (<a class="el" href="structmip_1_1C_1_1mip__interface.html">mip_interface</a> *device, uint8_t descriptor_set, uint8_t cmd_descriptor, const uint8_t *cmd_data, uint8_t cmd_length, uint8_t response_descriptor, uint8_t *response_buffer, uint8_t *response_length_inout)</td></tr>
<tr class="memdesc:gaa8167db65f8a63ecf98e2e378b75e242"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runs a command using a pre-serialized payload.  <a href="group__mip__interface__c.html#gaa8167db65f8a63ecf98e2e378b75e242">More...</a><br /></td></tr>
<tr class="separator:gaa8167db65f8a63ecf98e2e378b75e242"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga211b1d911fe427568f2385d4258ccbdf"><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="group__mip__c.html#gab3f1cea4c06739d4530f7d8088bd3ed8">mip_cmd_result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mip__interface__c.html#ga211b1d911fe427568f2385d4258ccbdf">mip::C::mip_interface_run_command_packet</a> (<a class="el" href="structmip_1_1C_1_1mip__interface.html">mip_interface</a> *device, const <a class="el" href="structmip_1_1C_1_1mip__packet__view.html">mip_packet_view</a> *packet, <a class="el" href="structmip_1_1C_1_1mip__pending__cmd.html">mip_pending_cmd</a> *cmd)</td></tr>
<tr class="memdesc:ga211b1d911fe427568f2385d4258ccbdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to mip_interface_start_command_packet but waits for the command to complete.  <a href="group__mip__interface__c.html#ga211b1d911fe427568f2385d4258ccbdf">More...</a><br /></td></tr>
<tr class="separator:ga211b1d911fe427568f2385d4258ccbdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb970e080a6da2600cd699e7a54afea7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mip__interface__c.html#gaeb970e080a6da2600cd699e7a54afea7">mip::C::mip_interface_start_command_packet</a> (<a class="el" href="structmip_1_1C_1_1mip__interface.html">mip_interface</a> *device, const <a class="el" href="structmip_1_1C_1_1mip__packet__view.html">mip_packet_view</a> *packet, <a class="el" href="structmip_1_1C_1_1mip__pending__cmd.html">mip_pending_cmd</a> *cmd)</td></tr>
<tr class="memdesc:gaeb970e080a6da2600cd699e7a54afea7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queues the command and sends the packet. Does not wait for completion.  <a href="group__mip__interface__c.html#gaeb970e080a6da2600cd699e7a54afea7">More...</a><br /></td></tr>
<tr class="separator:gaeb970e080a6da2600cd699e7a54afea7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga39ccf725f40268933173370b70008dad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mip__interface__c.html#ga39ccf725f40268933173370b70008dad">mip::C::mip_interface_register_packet_callback</a> (<a class="el" href="structmip_1_1C_1_1mip__interface.html">mip_interface</a> *device, <a class="el" href="structmip_1_1C_1_1mip__dispatch__handler.html">mip_dispatch_handler</a> *handler, uint8_t descriptor_set, bool after_fields, <a class="el" href="group__MipDispatch__c.html#ga29b0f63f4f34c796757047479d38427f">mip_dispatch_packet_callback</a> callback, void *user_data)</td></tr>
<tr class="memdesc:ga39ccf725f40268933173370b70008dad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers a callback for packets of the specified descriptor set.  <a href="group__mip__interface__c.html#ga39ccf725f40268933173370b70008dad">More...</a><br /></td></tr>
<tr class="separator:ga39ccf725f40268933173370b70008dad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61695d9789777b9f1e5c88f7e2fb4f96"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mip__interface__c.html#ga61695d9789777b9f1e5c88f7e2fb4f96">mip::C::mip_interface_register_field_callback</a> (<a class="el" href="structmip_1_1C_1_1mip__interface.html">mip_interface</a> *device, <a class="el" href="structmip_1_1C_1_1mip__dispatch__handler.html">mip_dispatch_handler</a> *handler, uint8_t descriptor_set, uint8_t field_descriptor, <a class="el" href="group__MipDispatch__c.html#ga6d9c2aca747e6ea40a7104054432241a">mip_dispatch_field_callback</a> callback, void *user_data)</td></tr>
<tr class="memdesc:ga61695d9789777b9f1e5c88f7e2fb4f96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers a callback for packets of the specified descriptor set.  <a href="group__mip__interface__c.html#ga61695d9789777b9f1e5c88f7e2fb4f96">More...</a><br /></td></tr>
<tr class="separator:ga61695d9789777b9f1e5c88f7e2fb4f96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a08598617516359275221826483dea2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mip__interface__c.html#ga1a08598617516359275221826483dea2">mip::C::mip_interface_register_extractor</a> (<a class="el" href="structmip_1_1C_1_1mip__interface.html">mip_interface</a> *device, <a class="el" href="structmip_1_1C_1_1mip__dispatch__handler.html">mip_dispatch_handler</a> *handler, uint8_t descriptor_set, uint8_t field_descriptor, <a class="el" href="group__MipDispatch__c.html#ga30f5663974ed1e5cb0e259d440aaa2e8">mip_dispatch_extractor</a> extractor, void *field_ptr)</td></tr>
<tr class="memdesc:ga1a08598617516359275221826483dea2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers a callback for packets of the specified descriptor set.  <a href="group__mip__interface__c.html#ga1a08598617516359275221826483dea2">More...</a><br /></td></tr>
<tr class="separator:ga1a08598617516359275221826483dea2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac2e422a505fec502cf397ee176a9fe03"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mip__interface__c.html#gac2e422a505fec502cf397ee176a9fe03">mip::C::mip_interface_set_recv_function</a> (<a class="el" href="structmip_1_1C_1_1mip__interface.html">mip_interface</a> *device, <a class="el" href="group__mip__interface__c.html#ga5c3a2f3d1dd0b7345e46144f83c7d16c">mip_recv_callback</a> callback)</td></tr>
<tr class="memdesc:gac2e422a505fec502cf397ee176a9fe03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the receive callback function.  <a href="group__mip__interface__c.html#gac2e422a505fec502cf397ee176a9fe03">More...</a><br /></td></tr>
<tr class="separator:gac2e422a505fec502cf397ee176a9fe03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad47d2021b148c42a9c73540c8cdccab8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mip__interface__c.html#gad47d2021b148c42a9c73540c8cdccab8">mip::C::mip_interface_set_send_function</a> (<a class="el" href="structmip_1_1C_1_1mip__interface.html">mip_interface</a> *device, <a class="el" href="group__mip__interface__c.html#ga1ab538fe6a048b11f97174b2f1ecc3de">mip_send_callback</a> callback)</td></tr>
<tr class="memdesc:gad47d2021b148c42a9c73540c8cdccab8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the send callback function.  <a href="group__mip__interface__c.html#gad47d2021b148c42a9c73540c8cdccab8">More...</a><br /></td></tr>
<tr class="separator:gad47d2021b148c42a9c73540c8cdccab8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f13668bc0b14554cf70db4dada8de6b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mip__interface__c.html#ga5f13668bc0b14554cf70db4dada8de6b">mip::C::mip_interface_set_update_function</a> (<a class="el" href="structmip_1_1C_1_1mip__interface.html">mip_interface</a> *device, <a class="el" href="group__mip__interface__c.html#ga87201ed89cfecf0d2b31a9297bbb93e8">mip_update_callback</a> callback)</td></tr>
<tr class="memdesc:ga5f13668bc0b14554cf70db4dada8de6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the update function.  <a href="group__mip__interface__c.html#ga5f13668bc0b14554cf70db4dada8de6b">More...</a><br /></td></tr>
<tr class="separator:ga5f13668bc0b14554cf70db4dada8de6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1f9785e21e20bd4fea3e18f7be54d97"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mip__interface__c.html#gaf1f9785e21e20bd4fea3e18f7be54d97">mip::C::mip_interface_set_user_pointer</a> (<a class="el" href="structmip_1_1C_1_1mip__interface.html">mip_interface</a> *device, void *pointer)</td></tr>
<tr class="memdesc:gaf1f9785e21e20bd4fea3e18f7be54d97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets an optional user data pointer which can be retrieved later.  <a href="group__mip__interface__c.html#gaf1f9785e21e20bd4fea3e18f7be54d97">More...</a><br /></td></tr>
<tr class="separator:gaf1f9785e21e20bd4fea3e18f7be54d97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga648c3178e6495eadc3eefbbfd0db4ddc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__mip__interface__c.html#ga5c3a2f3d1dd0b7345e46144f83c7d16c">mip_recv_callback</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mip__interface__c.html#ga648c3178e6495eadc3eefbbfd0db4ddc">mip::C::mip_interface_recv_function</a> (const <a class="el" href="structmip_1_1C_1_1mip__interface.html">mip_interface</a> *device)</td></tr>
<tr class="memdesc:ga648c3178e6495eadc3eefbbfd0db4ddc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the receive function pointer.  <a href="group__mip__interface__c.html#ga648c3178e6495eadc3eefbbfd0db4ddc">More...</a><br /></td></tr>
<tr class="separator:ga648c3178e6495eadc3eefbbfd0db4ddc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4bb1a462c7cfb3d80aca3dd8c2e102c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__mip__interface__c.html#ga1ab538fe6a048b11f97174b2f1ecc3de">mip_send_callback</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mip__interface__c.html#ga4bb1a462c7cfb3d80aca3dd8c2e102c4">mip::C::mip_interface_send_function</a> (const <a class="el" href="structmip_1_1C_1_1mip__interface.html">mip_interface</a> *device)</td></tr>
<tr class="memdesc:ga4bb1a462c7cfb3d80aca3dd8c2e102c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the send function pointer.  <a href="group__mip__interface__c.html#ga4bb1a462c7cfb3d80aca3dd8c2e102c4">More...</a><br /></td></tr>
<tr class="separator:ga4bb1a462c7cfb3d80aca3dd8c2e102c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga808240bdd0466d64bb39914552d99626"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__mip__interface__c.html#ga87201ed89cfecf0d2b31a9297bbb93e8">mip_update_callback</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mip__interface__c.html#ga808240bdd0466d64bb39914552d99626">mip::C::mip_interface_update_function</a> (const <a class="el" href="structmip_1_1C_1_1mip__interface.html">mip_interface</a> *device)</td></tr>
<tr class="memdesc:ga808240bdd0466d64bb39914552d99626"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the update function pointer.  <a href="group__mip__interface__c.html#ga808240bdd0466d64bb39914552d99626">More...</a><br /></td></tr>
<tr class="separator:ga808240bdd0466d64bb39914552d99626"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2750768245faf4e43888df0b05353ae3"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mip__interface__c.html#ga2750768245faf4e43888df0b05353ae3">mip::C::mip_interface_user_pointer</a> (const <a class="el" href="structmip_1_1C_1_1mip__interface.html">mip_interface</a> *device)</td></tr>
<tr class="memdesc:ga2750768245faf4e43888df0b05353ae3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the pointer set by <a class="el" href="group__mip__interface__c.html#gaf1f9785e21e20bd4fea3e18f7be54d97" title="Sets an optional user data pointer which can be retrieved later.">mip_interface_set_user_pointer()</a>.  <a href="group__mip__interface__c.html#ga2750768245faf4e43888df0b05353ae3">More...</a><br /></td></tr>
<tr class="separator:ga2750768245faf4e43888df0b05353ae3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe081a48f2bd1308603fdd08542c2e92"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmip_1_1C_1_1mip__parser.html">mip_parser</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mip__interface__c.html#gabe081a48f2bd1308603fdd08542c2e92">mip::C::mip_interface_parser</a> (<a class="el" href="structmip_1_1C_1_1mip__interface.html">mip_interface</a> *device)</td></tr>
<tr class="memdesc:gabe081a48f2bd1308603fdd08542c2e92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the MIP parser for the device.  <a href="group__mip__interface__c.html#gabe081a48f2bd1308603fdd08542c2e92">More...</a><br /></td></tr>
<tr class="separator:gabe081a48f2bd1308603fdd08542c2e92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad780a59de3d705f5d9452445795e9948"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmip_1_1C_1_1mip__cmd__queue.html">mip_cmd_queue</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mip__interface__c.html#gad780a59de3d705f5d9452445795e9948">mip::C::mip_interface_cmd_queue</a> (<a class="el" href="structmip_1_1C_1_1mip__interface.html">mip_interface</a> *device)</td></tr>
<tr class="memdesc:gad780a59de3d705f5d9452445795e9948"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the commmand queue for the device.  <a href="group__mip__interface__c.html#gad780a59de3d705f5d9452445795e9948">More...</a><br /></td></tr>
<tr class="separator:gad780a59de3d705f5d9452445795e9948"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>High-level C functions for controlling a MIP device. </p>
<p>This module contains functions and classes for communicating with a MIP device in <a class="el" href="namespacemip_1_1C.html">C</a>.</p>
<ul>
<li>Sending commands </li>
<li>Receiving Data </li>
</ul>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="gaad6898733d3e1d41d14a84280c5435fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaad6898733d3e1d41d14a84280c5435fa">&#9670;&nbsp;</a></span>mip_interface</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structmip_1_1C_1_1mip__interface.html">mip::C::mip_interface</a> <a class="el" href="structmip_1_1C_1_1mip__interface.html">mip::C::mip_interface</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>State of the interface for communicating with a MIP device. </p>

</div>
</div>
<a id="ga5c3a2f3d1dd0b7345e46144f83c7d16c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5c3a2f3d1dd0b7345e46144f83c7d16c">&#9670;&nbsp;</a></span>mip_recv_callback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mip::C::mip_recv_callback</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called from <a class="el" href="group__mip__interface__c.html#ga556502e5eba49d92af8ee84ed3ae36c0" title="Checks for data at the port and reads it into buffer.">mip_interface_recv_from_device()</a> to receive data from the device port. </p>
<p>This is called indirectly through <a class="el" href="group__mip__interface__c.html#gabc671aab52f5f4281aee67f8453125de" title="Call to process data from the device.">mip_interface_update()</a> to poll for new data and command responses. For single-threaded applications, it will be called while waiting for command replies.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>A pointer to the device interface. Applications can use the user data pointer to access additional information such as the port handle.</td></tr>
    <tr><td class="paramname">wait_time</td><td>Time to wait for data from the device. The actual time waited may be less than wait_time, but it should not significantly exceed this value.</td></tr>
    <tr><td class="paramname">from_cmd</td><td>If true, this call is a result of waiting for a command to complete. Otherwise, this call is a regularly- scheduled poll for data.</td></tr>
    <tr><td class="paramname">timestamp_out</td><td>Timestamp of the data that was received.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if successful, even if no data is received. </dd>
<dd>
False if the port cannot be read or some other error occurs (e.g. if the port is closed). If this function returns false when from_cmd is true, the corresponding command will fail with MIP_STATUS_ERROR.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Except in case of error (i.e. returning false), the timestamp must be set even if no data is received. This is required to allow commands to time out when no response is received.</dd>
<dd>
Applications may sleep the thread or enter a low-power state while waiting for data. On posix-like (e.g. desktop) systems, applications should call <a class="el" href="namespacemicrostrain_1_1serialization_1_1big__endian.html#ada0e1fcbef4cdf124ce17c0362de8101">read()</a> with a maximum timeout of wait_time. If the actual wait time is less than the requested duration, this function may be called again by the MIP SDK to wait the remaining time. If the actual wait time exceeds wait_time, command timeouts may take longer than intended.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__mip__interface__c.html#ga556502e5eba49d92af8ee84ed3ae36c0" title="Checks for data at the port and reads it into buffer.">mip_interface_recv_from_device</a> </dd></dl>

</div>
</div>
<a id="ga1ab538fe6a048b11f97174b2f1ecc3de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1ab538fe6a048b11f97174b2f1ecc3de">&#9670;&nbsp;</a></span>mip_send_callback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mip::C::mip_send_callback</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called from <a class="el" href="group__mip__interface__c.html#ga04a725bcf412e0c7bc4c7c53b74c5553" title="Sends data to the port (i.e. from this library to the physical device).">mip_interface_send_to_device()</a> to send data to the device port. The application should forward the data to the device port (e.g. a serial port, TCP connection, etc). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>A pointer to the device interface. Applications can use the user data pointer to access additional information such as the port handle.</td></tr>
    <tr><td class="paramname">data</td><td>Buffer containing the data to be transmitted to the device.</td></tr>
    <tr><td class="paramname">length</td><td>Length of data to transmit.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if all of the data was successfully transmitted. </dd>
<dd>
False if an error occurred and some or all data was definitely unable to be transmitted. </dd>
<dd>
Applications should prefer returning true if success is uncertain since command timeouts will help detect failed transmissions. If this function returns false, the associated command will fail with <a class="el" href="structmip_1_1CmdResult.html#a2a35f52861d1047e7d4801418fbb1dee" title="Command could not be executed (error sending/receiving)">CmdResult::STATUS_ERROR</a>. Commands will time out in case of undetected transmission failures, so false positives are OK. False negatives will cause commands to immediately fail even if sent successfully however, and the unexpected ack/nack replies increase the risk of confusing which replies go with which commands. </dd></dl>

</div>
</div>
<a id="ga87201ed89cfecf0d2b31a9297bbb93e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga87201ed89cfecf0d2b31a9297bbb93e8">&#9670;&nbsp;</a></span>mip_update_callback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mip::C::mip_update_callback</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback function typedef for custom update behavior. </p>
<p>This function is called whenever data should be parsed from the port: </p><ul>
<li>While waiting for command responses </li>
<li>To check for new data packets</li>
</ul>
<p>Generally an application should call <a class="el" href="group__mip__interface__c.html#ga556502e5eba49d92af8ee84ed3ae36c0" title="Checks for data at the port and reads it into buffer.">mip_interface_recv_from_device()</a> from within this callback and pass the data to <a class="el" href="group__mip__interface__c.html#ga800e3595cd010513a8c0f7a8591c76f3" title="Passes data from the device into the parser.">mip_interface_input_bytes_from_device()</a>. Many applications can set this callback to <a class="el" href="group__mip__interface__c.html#gaf35d6a824e64ec29031a219fbeccd99a" title="Polls the port for new data or command replies.">mip_interface_default_update()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The <a class="el" href="structmip_1_1C_1_1mip__interface.html" title="State of the interface for communicating with a MIP device.">mip_interface</a> object being updated. </td></tr>
    <tr><td class="paramname">timeout</td><td>Approximate amount of time to wait for data from the device. This may be an underestimate, but applications should not wait significantly longer as this may cause commands to take longer to time out. </td></tr>
    <tr><td class="paramname">from_cmd</td><td>If true, this call is a result of waiting for a command to complete. Otherwise, this call is a regularly-scheduled poll for data. Typically an application will not wait for more data if this is false, or may sleep while waiting if this is true.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if successful (even if no data is received). </dd>
<dd>
False if an error occurs and the port cannot be read (e.g. if the port is closed). Returning false will cause any pending commands to fail with a status error code.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This update call should not return false (i.e. failure) when from_cmd is true and reception is handled by another thread, unless that thread is not currently running. Otherwise a race condition may occur in the command queue. </dd></dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gad780a59de3d705f5d9452445795e9948"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad780a59de3d705f5d9452445795e9948">&#9670;&nbsp;</a></span>mip_interface_cmd_queue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmip_1_1C_1_1mip__cmd__queue.html">mip_cmd_queue</a> * mip::C::mip_interface_cmd_queue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmip_1_1C_1_1mip__interface.html">mip_interface</a> *&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the commmand queue for the device. </p>

</div>
</div>
<a id="gaf35d6a824e64ec29031a219fbeccd99a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf35d6a824e64ec29031a219fbeccd99a">&#9670;&nbsp;</a></span>mip_interface_default_update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mip::C::mip_interface_default_update </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmip_1_1C_1_1mip__interface.html">mip_interface</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemip_1_1C.html#aeb7a010ab523fc31b023122aa9b8e524">mip_timeout</a>&#160;</td>
          <td class="paramname"><em>wait_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>from_cmd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Polls the port for new data or command replies. </p>
<p>This is the default choice for the user update function. It ignores the from_cmd flag and always tries to read data from the device.</p>
<dl class="section warning"><dt>Warning</dt><dd>This function is provided for convenience and quick setup. It will work for most applications, but it is not optimized for your application. It may be unsuitable for some situations such as small microcontrollers (due to the fixed-size stack-allocated data buffer) or in combination with multi-threading.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td></td></tr>
    <tr><td class="paramname">wait_time</td><td>Time to wait for data from the device. This will be nonzero when waiting for command replies. Applications calling this function can pass 0 to avoid blocking when checking for new data.</td></tr>
    <tr><td class="paramname">from_cmd</td><td>If true, this call is a result of waiting for a command to complete. Otherwise, this call is a regularly-scheduled poll for data. User code calling this function should generally set this to false.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value returned by mip_interface_user_recv_from_device. </dd></dl>

</div>
</div>
<a id="ga4c27a3c0cc93d4372cce72ed49bb3f1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4c27a3c0cc93d4372cce72ed49bb3f1b">&#9670;&nbsp;</a></span>mip_interface_default_update_ext_buffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mip::C::mip_interface_default_update_ext_buffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmip_1_1C_1_1mip__interface.html">mip_interface</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemip_1_1C.html#aeb7a010ab523fc31b023122aa9b8e524">mip_timeout</a>&#160;</td>
          <td class="paramname"><em>wait_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>from_cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>buffer_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Polls the port for new data or command replies using a supplied buffer. </p>
<p>This function is suitable for most single-threaded use cases where performance is not critical. In performance-sensitive applications, it's best to either read directly into the mip parser buffer, or call mip_interface_input_bytes from your own update function (bypassing mip_interface_recv_from_device entirely).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td></td></tr>
    <tr><td class="paramname">wait_time</td><td>Time to wait for data from the device. This will be nonzero when waiting for command replies. Applications calling this function can pass 0 to avoid blocking when checking for new data.</td></tr>
    <tr><td class="paramname">from_cmd</td><td>If true, this call is a result of waiting for a command to complete. Otherwise, this call is a regularly-scheduled poll for data. User code calling this function should generally set this to false.</td></tr>
    <tr><td class="paramname">buffer</td><td>Buffer to hold data read from the device connection. At least 512 bytes are recommended for better performance, with a few kB being the point of diminishing return.</td></tr>
    <tr><td class="paramname">buffer_size</td><td>Size of the buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value returned by mip_interface_user_recv_from_device. </dd></dl>

</div>
</div>
<a id="ga38ee5f31ce57f30418fc2a9e3970e082"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga38ee5f31ce57f30418fc2a9e3970e082">&#9670;&nbsp;</a></span>mip_interface_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mip::C::mip_interface_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmip_1_1C_1_1mip__interface.html">mip_interface</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemip_1_1C.html#aeb7a010ab523fc31b023122aa9b8e524">mip_timeout</a>&#160;</td>
          <td class="paramname"><em>parse_timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemip_1_1C.html#aeb7a010ab523fc31b023122aa9b8e524">mip_timeout</a>&#160;</td>
          <td class="paramname"><em>base_reply_timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mip__interface__c.html#ga1ab538fe6a048b11f97174b2f1ecc3de">mip_send_callback</a>&#160;</td>
          <td class="paramname"><em>send</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mip__interface__c.html#ga5c3a2f3d1dd0b7345e46144f83c7d16c">mip_recv_callback</a>&#160;</td>
          <td class="paramname"><em>recv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mip__interface__c.html#ga87201ed89cfecf0d2b31a9297bbb93e8">mip_update_callback</a>&#160;</td>
          <td class="paramname"><em>update</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_pointer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the <a class="el" href="structmip_1_1C_1_1mip__interface.html" title="State of the interface for communicating with a MIP device.">mip_interface</a> components. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td></td></tr>
    <tr><td class="paramname">parse_timeout</td><td>Maximum length of time to wait for the end of a MIP packet. See <a class="el" href="group__mip__parser__c.html#ga54bf470ed57858c6483968e812308fb3" title="Initializes the MIP parser.">mip_parser_init()</a>. </td></tr>
    <tr><td class="paramname">base_reply_timeout</td><td>Minimum time for all commands. See <a class="el" href="group__MipCommandQueue__c.html#ga03ff5d25ee6c5a58e9c34de62f27462c" title="Initializes a command queue.">mip_cmd_queue_init()</a>. </td></tr>
    <tr><td class="paramname">send</td><td>A callback which is called to send data to the device. </td></tr>
    <tr><td class="paramname">recv</td><td>A callback which is called when data needs to be read from the device. </td></tr>
    <tr><td class="paramname">update</td><td>Optional callback which is called to perform routine tasks such as checking for command timeouts. Defaults to mip_interface_default_update. </td></tr>
    <tr><td class="paramname">user_pointer</td><td>Optional pointer which is passed to the send, recv, and update callbacks. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2aee551e276ed77732c45a23d0c70b82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2aee551e276ed77732c45a23d0c70b82">&#9670;&nbsp;</a></span>mip_interface_input_bytes_andor_time()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mip::C::mip_interface_input_bytes_andor_time </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmip_1_1C_1_1mip__interface.html">mip_interface</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>received_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>data_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemip_1_1C.html#a8a24a1913ffba77cdd608c5fb7575f37">mip_timestamp</a>&#160;</td>
          <td class="paramname"><em>now</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function takes care of processing received data and updating the current time. </p>
<p>User-defined update functions should either call this function after getting data from the connection, or do the equivalent manually: </p><ul>
<li>Input bytes to the parser, via mip_interface_input_bytes_from_device, and </li>
<li>Update the current time via mip_interface_update_time </li>
</ul>

</div>
</div>
<a id="ga800e3595cd010513a8c0f7a8591c76f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga800e3595cd010513a8c0f7a8591c76f3">&#9670;&nbsp;</a></span>mip_interface_input_bytes_from_device()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mip::C::mip_interface_input_bytes_from_device </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmip_1_1C_1_1mip__interface.html">mip_interface</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemip_1_1C.html#a8a24a1913ffba77cdd608c5fb7575f37">mip_timestamp</a>&#160;</td>
          <td class="paramname"><em>timestamp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Passes data from the device into the parser. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td></td></tr>
    <tr><td class="paramname">data</td><td>Input data buffer. May be NULL if length == 0. </td></tr>
    <tr><td class="paramname">length</td><td>Length of the input buffer. Must be 0 if data is NULL. </td></tr>
    <tr><td class="paramname">timestamp</td><td>Time of the received data. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga211fe6ffec9ce7fb891269068e738ed2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga211fe6ffec9ce7fb891269068e738ed2">&#9670;&nbsp;</a></span>mip_interface_input_packet_from_device()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mip::C::mip_interface_input_packet_from_device </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmip_1_1C_1_1mip__interface.html">mip_interface</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmip_1_1C_1_1mip__packet__view.html">mip_packet_view</a> *&#160;</td>
          <td class="paramname"><em>packet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemip_1_1C.html#a8a24a1913ffba77cdd608c5fb7575f37">mip_timestamp</a>&#160;</td>
          <td class="paramname"><em>timestamp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Processes a pre-parsed packet for command replies and data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td></td></tr>
    <tr><td class="paramname">packet</td><td>The received MIP packet. </td></tr>
    <tr><td class="paramname">timestamp</td><td>Timestamp of the received MIP packet. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga15f97e860ab600fe3982e4ad5b289d65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga15f97e860ab600fe3982e4ad5b289d65">&#9670;&nbsp;</a></span>mip_interface_parse_callback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mip::C::mip_interface_parse_callback </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmip_1_1C_1_1mip__packet__view.html">mip_packet_view</a> *&#160;</td>
          <td class="paramname"><em>packet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemip_1_1C.html#a8a24a1913ffba77cdd608c5fb7575f37">mip_timestamp</a>&#160;</td>
          <td class="paramname"><em>timestamp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrapper around mip_interface_input_packet_from_device for use with <a class="el" href="structmip_1_1C_1_1mip__parser.html" title="MIP Parser state.">mip_parser</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>Void pointer to the device. Must be a <a class="el" href="structmip_1_1C_1_1mip__interface.html" title="State of the interface for communicating with a MIP device.">mip_interface</a> pointer. </td></tr>
    <tr><td class="paramname">packet</td><td>MIP Packet from the parser. </td></tr>
    <tr><td class="paramname">timestamp</td><td>Timestamp of the packet. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gabe081a48f2bd1308603fdd08542c2e92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabe081a48f2bd1308603fdd08542c2e92">&#9670;&nbsp;</a></span>mip_interface_parser()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmip_1_1C_1_1mip__parser.html">mip_parser</a> * mip::C::mip_interface_parser </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmip_1_1C_1_1mip__interface.html">mip_interface</a> *&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the MIP parser for the device. </p>

</div>
</div>
<a id="ga556502e5eba49d92af8ee84ed3ae36c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga556502e5eba49d92af8ee84ed3ae36c0">&#9670;&nbsp;</a></span>mip_interface_recv_from_device()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mip::C::mip_interface_recv_from_device </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmip_1_1C_1_1mip__interface.html">mip_interface</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemip_1_1C.html#aeb7a010ab523fc31b023122aa9b8e524">mip_timeout</a>&#160;</td>
          <td class="paramname"><em>wait_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>from_cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>length_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemip_1_1C.html#a8a24a1913ffba77cdd608c5fb7575f37">mip_timestamp</a> *&#160;</td>
          <td class="paramname"><em>timestamp_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks for data at the port and reads it into buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td></td></tr>
    <tr><td class="paramname">buffer</td><td>A place to store the data. </td></tr>
    <tr><td class="paramname">max_length</td><td>Maximum number of bytes to read into buffer. </td></tr>
    <tr><td class="paramname">wait_time</td><td>Maximum time to wait for data. May be 0. </td></tr>
    <tr><td class="paramname">length_out</td><td>The number of bytes successfully read into buffer. </td></tr>
    <tr><td class="paramname">timestamp_out</td><td>The timestamp of the received data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if successful (even if 0 bytes were read). </dd>
<dd>
False if the receive callback is NULL. </dd>
<dd>
False if the receive callback failed (i.e. if it returned false). </dd></dl>

</div>
</div>
<a id="ga648c3178e6495eadc3eefbbfd0db4ddc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga648c3178e6495eadc3eefbbfd0db4ddc">&#9670;&nbsp;</a></span>mip_interface_recv_function()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__mip__interface__c.html#ga5c3a2f3d1dd0b7345e46144f83c7d16c">mip_recv_callback</a> mip::C::mip_interface_recv_function </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmip_1_1C_1_1mip__interface.html">mip_interface</a> *&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the receive function pointer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The receive callback function. May be NULL. </dd></dl>

</div>
</div>
<a id="ga1a08598617516359275221826483dea2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1a08598617516359275221826483dea2">&#9670;&nbsp;</a></span>mip_interface_register_extractor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mip::C::mip_interface_register_extractor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmip_1_1C_1_1mip__interface.html">mip_interface</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmip_1_1C_1_1mip__dispatch__handler.html">mip_dispatch_handler</a> *&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>descriptor_set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>field_descriptor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__MipDispatch__c.html#ga30f5663974ed1e5cb0e259d440aaa2e8">mip_dispatch_extractor</a>&#160;</td>
          <td class="paramname"><em>extractor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>field_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Registers a callback for packets of the specified descriptor set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td></td></tr>
    <tr><td class="paramname">handler</td><td>An uninitialized <a class="el" href="structmip_1_1C_1_1mip__dispatch__handler.html" title="Handler information for MIP Packet or Field callbacks.">mip_dispatch_handler</a> object. This call will initialize it. </td></tr>
    <tr><td class="paramname">descriptor_set</td><td></td></tr>
    <tr><td class="paramname">field_descriptor</td><td></td></tr>
    <tr><td class="paramname">extractor</td><td></td></tr>
    <tr><td class="paramname">field_ptr</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>mip_dispatch_handler_init_extract_handler for details. </dd></dl>

</div>
</div>
<a id="ga61695d9789777b9f1e5c88f7e2fb4f96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga61695d9789777b9f1e5c88f7e2fb4f96">&#9670;&nbsp;</a></span>mip_interface_register_field_callback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mip::C::mip_interface_register_field_callback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmip_1_1C_1_1mip__interface.html">mip_interface</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmip_1_1C_1_1mip__dispatch__handler.html">mip_dispatch_handler</a> *&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>descriptor_set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>field_descriptor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__MipDispatch__c.html#ga6d9c2aca747e6ea40a7104054432241a">mip_dispatch_field_callback</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Registers a callback for packets of the specified descriptor set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td></td></tr>
    <tr><td class="paramname">handler</td><td>An uninitialized <a class="el" href="structmip_1_1C_1_1mip__dispatch__handler.html" title="Handler information for MIP Packet or Field callbacks.">mip_dispatch_handler</a> object. This call will initialize it. </td></tr>
    <tr><td class="paramname">descriptor_set</td><td></td></tr>
    <tr><td class="paramname">field_descriptor</td><td></td></tr>
    <tr><td class="paramname">callback</td><td></td></tr>
    <tr><td class="paramname">user_data</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__MipDispatchHandler__c.html#ga46a67a910c2ee93e7ad4c65eb9bd47f8" title="Initialize the dispatch handler with a field callback.">mip_dispatch_handler_init_field_handler</a> for details. </dd></dl>

</div>
</div>
<a id="ga39ccf725f40268933173370b70008dad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga39ccf725f40268933173370b70008dad">&#9670;&nbsp;</a></span>mip_interface_register_packet_callback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mip::C::mip_interface_register_packet_callback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmip_1_1C_1_1mip__interface.html">mip_interface</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmip_1_1C_1_1mip__dispatch__handler.html">mip_dispatch_handler</a> *&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>descriptor_set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>after_fields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__MipDispatch__c.html#ga29b0f63f4f34c796757047479d38427f">mip_dispatch_packet_callback</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Registers a callback for packets of the specified descriptor set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td></td></tr>
    <tr><td class="paramname">handler</td><td>An uninitialized <a class="el" href="structmip_1_1C_1_1mip__dispatch__handler.html" title="Handler information for MIP Packet or Field callbacks.">mip_dispatch_handler</a> object. This call will initialize it. </td></tr>
    <tr><td class="paramname">descriptor_set</td><td></td></tr>
    <tr><td class="paramname">after_fields</td><td></td></tr>
    <tr><td class="paramname">callback</td><td></td></tr>
    <tr><td class="paramname">user_data</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__MipDispatchHandler__c.html#ga6949bdc8395ed92fab2948f1c26ec144" title="Initialize the dispatch handler with a packet callback.">mip_dispatch_handler_init_packet_handler</a> for details. </dd></dl>

</div>
</div>
<a id="ga4528ffd3e7252186568648cae4fece8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4528ffd3e7252186568648cae4fece8c">&#9670;&nbsp;</a></span>mip_interface_run_command()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__mip__c.html#gab3f1cea4c06739d4530f7d8088bd3ed8">mip_cmd_result</a> mip::C::mip_interface_run_command </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmip_1_1C_1_1mip__interface.html">mip_interface</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>descriptor_set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>cmd_descriptor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>cmd_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>cmd_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Runs a command using a pre-serialized payload. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td></td></tr>
    <tr><td class="paramname">descriptor_set</td><td>Command descriptor set. </td></tr>
    <tr><td class="paramname">cmd_descriptor</td><td>Command field descriptor. </td></tr>
    <tr><td class="paramname">cmd_data</td><td>Optional payload data. May be NULL if cmd_length == 0. </td></tr>
    <tr><td class="paramname">cmd_length</td><td>Length of the command payload (parameters).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>mip_cmd_result MIP_ACK_OK - Command completed successfully. MIP_NACK_* - Device rejected the command. MIP_STATUS_* - An error occured (e.g. timeout). </dd></dl>

</div>
</div>
<a id="ga211b1d911fe427568f2385d4258ccbdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga211b1d911fe427568f2385d4258ccbdf">&#9670;&nbsp;</a></span>mip_interface_run_command_packet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__mip__c.html#gab3f1cea4c06739d4530f7d8088bd3ed8">mip_cmd_result</a> mip::C::mip_interface_run_command_packet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmip_1_1C_1_1mip__interface.html">mip_interface</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmip_1_1C_1_1mip__packet__view.html">mip_packet_view</a> *&#160;</td>
          <td class="paramname"><em>packet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmip_1_1C_1_1mip__pending__cmd.html">mip_pending_cmd</a> *&#160;</td>
          <td class="paramname"><em>cmd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Similar to mip_interface_start_command_packet but waits for the command to complete. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td></td></tr>
    <tr><td class="paramname">packet</td><td>A MIP packet containing the command. </td></tr>
    <tr><td class="paramname">cmd</td><td>The command status tracker. No lifetime requirement. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa8167db65f8a63ecf98e2e378b75e242"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa8167db65f8a63ecf98e2e378b75e242">&#9670;&nbsp;</a></span>mip_interface_run_command_with_response()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__mip__c.html#gab3f1cea4c06739d4530f7d8088bd3ed8">mip_cmd_result</a> mip::C::mip_interface_run_command_with_response </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmip_1_1C_1_1mip__interface.html">mip_interface</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>descriptor_set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>cmd_descriptor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>cmd_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>cmd_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>response_descriptor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>response_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>response_length_inout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Runs a command using a pre-serialized payload. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">device</td><td></td></tr>
    <tr><td class="paramdir"></td><td class="paramname">descriptor_set</td><td>Command descriptor set. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">cmd_descriptor</td><td>Command field descriptor. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">cmd_data</td><td>Optional payload data. May be NULL if cmd_length == 0. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">cmd_length</td><td>Length of the command payload (parameters). </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">response_descriptor</td><td>Descriptor of the response data. May be MIP_INVALID_FIELD_DESCRIPTOR if no response is expected. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">response_buffer</td><td>Buffer to hold response data. Can be the same as the command data buffer. Can be NULL if response_descriptor is MIP_INVALID_FIELD_DESCRIPTOR. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">response_length_inout</td><td>As input, the size of response buffer and max response length. As output, returns the actual length of the response data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>mip_cmd_result </dd></dl>

</div>
</div>
<a id="ga4bb1a462c7cfb3d80aca3dd8c2e102c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4bb1a462c7cfb3d80aca3dd8c2e102c4">&#9670;&nbsp;</a></span>mip_interface_send_function()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__mip__interface__c.html#ga1ab538fe6a048b11f97174b2f1ecc3de">mip_send_callback</a> mip::C::mip_interface_send_function </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmip_1_1C_1_1mip__interface.html">mip_interface</a> *&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the send function pointer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The send callback function. May be NULL. </dd></dl>

</div>
</div>
<a id="ga04a725bcf412e0c7bc4c7c53b74c5553"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga04a725bcf412e0c7bc4c7c53b74c5553">&#9670;&nbsp;</a></span>mip_interface_send_to_device()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mip::C::mip_interface_send_to_device </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmip_1_1C_1_1mip__interface.html">mip_interface</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends data to the port (i.e. from this library to the physical device). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The <a class="el" href="structmip_1_1C_1_1mip__interface.html" title="State of the interface for communicating with a MIP device.">mip_interface</a> object. </td></tr>
    <tr><td class="paramname">data</td><td>Data to be sent. </td></tr>
    <tr><td class="paramname">length</td><td>Length of data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the data was sent successfully. </dd>
<dd>
False if the send callback is NULL. </dd>
<dd>
False if some or all data could not be sent.</dd></dl>
<p>This is called whenever bytes must be sent to the physical device. </p>

</div>
</div>
<a id="gac2e422a505fec502cf397ee176a9fe03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac2e422a505fec502cf397ee176a9fe03">&#9670;&nbsp;</a></span>mip_interface_set_recv_function()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mip::C::mip_interface_set_recv_function </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmip_1_1C_1_1mip__interface.html">mip_interface</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mip__interface__c.html#ga5c3a2f3d1dd0b7345e46144f83c7d16c">mip_recv_callback</a>&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the receive callback function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td></td></tr>
    <tr><td class="paramname">callback</td><td>Function which gets data from the device connection. If this is NULL then commands will fail and no data will be received. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad47d2021b148c42a9c73540c8cdccab8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad47d2021b148c42a9c73540c8cdccab8">&#9670;&nbsp;</a></span>mip_interface_set_send_function()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mip::C::mip_interface_set_send_function </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmip_1_1C_1_1mip__interface.html">mip_interface</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mip__interface__c.html#ga1ab538fe6a048b11f97174b2f1ecc3de">mip_send_callback</a>&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the send callback function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td></td></tr>
    <tr><td class="paramname">callback</td><td>Function which sends raw bytes to the device. This can be NULL if no commands will be issued (they would fail). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5f13668bc0b14554cf70db4dada8de6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5f13668bc0b14554cf70db4dada8de6b">&#9670;&nbsp;</a></span>mip_interface_set_update_function()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mip::C::mip_interface_set_update_function </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmip_1_1C_1_1mip__interface.html">mip_interface</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mip__interface__c.html#ga87201ed89cfecf0d2b31a9297bbb93e8">mip_update_callback</a>&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the update function. </p>
<p>By default, the update function is mip_interface_default_update.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__mip__interface__c.html#ga87201ed89cfecf0d2b31a9297bbb93e8" title="Callback function typedef for custom update behavior.">mip_update_callback</a> </dd>
<dd>
<a class="el" href="group__mip__interface__c.html#gabc671aab52f5f4281aee67f8453125de" title="Call to process data from the device.">mip_interface_update</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td></td></tr>
    <tr><td class="paramname">callback</td><td>Update function to call when polling the device for data. If this is NULL, then update calls will fail and no data or or command replies will be received. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf1f9785e21e20bd4fea3e18f7be54d97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf1f9785e21e20bd4fea3e18f7be54d97">&#9670;&nbsp;</a></span>mip_interface_set_user_pointer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mip::C::mip_interface_set_user_pointer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmip_1_1C_1_1mip__interface.html">mip_interface</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pointer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets an optional user data pointer which can be retrieved later. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td></td></tr>
    <tr><td class="paramname">pointer</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaeb970e080a6da2600cd699e7a54afea7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeb970e080a6da2600cd699e7a54afea7">&#9670;&nbsp;</a></span>mip_interface_start_command_packet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mip::C::mip_interface_start_command_packet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmip_1_1C_1_1mip__interface.html">mip_interface</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmip_1_1C_1_1mip__packet__view.html">mip_packet_view</a> *&#160;</td>
          <td class="paramname"><em>packet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmip_1_1C_1_1mip__pending__cmd.html">mip_pending_cmd</a> *&#160;</td>
          <td class="paramname"><em>cmd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Queues the command and sends the packet. Does not wait for completion. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td></td></tr>
    <tr><td class="paramname">packet</td><td>A MIP packet containing the command. </td></tr>
    <tr><td class="paramname">cmd</td><td>The command status tracker. Must be valid while the command executes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if successful. Cmd must remain valid until the command finishes. </dd>
<dd>
False on error sending the packet. No cleanup is necessary and cmd can be destroyed immediately afterward in this case. </dd></dl>

</div>
</div>
<a id="gabc671aab52f5f4281aee67f8453125de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabc671aab52f5f4281aee67f8453125de">&#9670;&nbsp;</a></span>mip_interface_update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mip::C::mip_interface_update </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmip_1_1C_1_1mip__interface.html">mip_interface</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemip_1_1C.html#aeb7a010ab523fc31b023122aa9b8e524">mip_timeout</a>&#160;</td>
          <td class="paramname"><em>wait_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>from_cmd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call to process data from the device. </p>
<p>This function is also called while waiting for command replies.</p>
<p>Call this periodically to process packets received from the device. It should be called at a suitably high rate to prevent the connection buffers from overflowing. The update rate affects the reception timestamp resolution.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td></td></tr>
    <tr><td class="paramname">wait_time</td><td>Time to wait for data from the device. This will be nonzero when waiting for command replies. Applications calling this function can pass 0 to avoid blocking when checking for new data.</td></tr>
    <tr><td class="paramname">from_cmd</td><td>If true, this call is a result of waiting for a command to complete. Otherwise, this call is a regularly-scheduled poll for data. User code calling this function should generally set this to false.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if operation should continue, or false if the device cannot be updated (e.g. if the serial port is not open). </dd></dl>

</div>
</div>
<a id="ga808240bdd0466d64bb39914552d99626"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga808240bdd0466d64bb39914552d99626">&#9670;&nbsp;</a></span>mip_interface_update_function()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__mip__interface__c.html#ga87201ed89cfecf0d2b31a9297bbb93e8">mip_update_callback</a> mip::C::mip_interface_update_function </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmip_1_1C_1_1mip__interface.html">mip_interface</a> *&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the update function pointer. </p>
<dl class="section return"><dt>Returns</dt><dd>The update function. Defaults to mip_interface_default_update. May be NULL. </dd></dl>

</div>
</div>
<a id="ga44b0500ae8cf2809f934893e2e47b8ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga44b0500ae8cf2809f934893e2e47b8ce">&#9670;&nbsp;</a></span>mip_interface_update_time()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mip::C::mip_interface_update_time </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmip_1_1C_1_1mip__interface.html">mip_interface</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemip_1_1C.html#a8a24a1913ffba77cdd608c5fb7575f37">mip_timestamp</a>&#160;</td>
          <td class="paramname"><em>timestamp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call this to ensure that pending commands time out properly. </p>
<p>This function should be called regularly (i.e. from within the update callback). Otherwise, unacknowledged commands may never time out. This can happen even if data is being sent through mip_interface_input_bytes_from_device because the device may be streaming data. See the implementation of mip_interface_default_update for an example.</p>
<p>param device param timestamp Current time, as if timestamping received data. </p>

</div>
</div>
<a id="ga2750768245faf4e43888df0b05353ae3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2750768245faf4e43888df0b05353ae3">&#9670;&nbsp;</a></span>mip_interface_user_pointer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * mip::C::mip_interface_user_pointer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmip_1_1C_1_1mip__interface.html">mip_interface</a> *&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the pointer set by <a class="el" href="group__mip__interface__c.html#gaf1f9785e21e20bd4fea3e18f7be54d97" title="Sets an optional user data pointer which can be retrieved later.">mip_interface_set_user_pointer()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The pointer value. </dd></dl>

</div>
</div>
<a id="gaaaedad73f9ab28beb69e2a1a8c9da636"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaaedad73f9ab28beb69e2a1a8c9da636">&#9670;&nbsp;</a></span>mip_interface_wait_for_reply()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__mip__c.html#gab3f1cea4c06739d4530f7d8088bd3ed8">mip_cmd_result</a> mip::C::mip_interface_wait_for_reply </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmip_1_1C_1_1mip__interface.html">mip_interface</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmip_1_1C_1_1mip__pending__cmd.html">mip_pending_cmd</a> *&#160;</td>
          <td class="paramname"><em>cmd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Blocks until the pending command completes or times out. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td></td></tr>
    <tr><td class="paramname">cmd</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The final status of the command. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
